<!doctype html><html lang=en-US xml:lang=en-US><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="text/html;charset=utf-8" http-equiv=Content-Type><link href=/favicon.svg rel=icon type=image/svg><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/main.css rel=stylesheet><meta content=#151515 name=theme-color><meta content=#151515 name=msapplication-navbutton-color><meta content=black-translucent name=apple-mobile-web-app-status-bar-style><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>jdrouet > Building a search engine from scratch, in Rust: part 1</title><meta content=Zola name=generator><meta content="Or how to write on disk efficiently in the browser or any other device." name=description><meta content="J√©r√©mie Drouet" name=author><link href=/posts/202503170800-search-engine-part-1/ rel=canonical><meta content="Building a search engine from scratch, in Rust: part 1" property=og:title><meta content="Or how to write on disk efficiently in the browser or any other device." property=og:description><meta content=article property=og:type><meta content=/posts/202503170800-search-engine-part-1/ property=og:url><meta content=/images/logo.png property=og:image><meta content=jdrouet property=og:site_name><meta content=en_US property=og:locale><meta content=2025-03-22T00:00:00+00:00 property=article:published_time><body><header><div class=container><a href=/ id=a-title> <h1>üßë‚Äçüíª jdrouet</h1> </a><h2>My projects, my thoughts and other things.</h2><nav id=navbar><a alt="Link to Home" class=btn href=/> Home </a><a alt="Link to LinkedIn profile" class=btn href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <span class="icon icon-linkedin"></span>About me</a><a alt="Link to GitHub profile" class=btn href=https://github.com/jdrouet target=_blank> <span class="icon icon-github"></span>jdrouet</a><a alt="Link to Mastodon profile" class=btn href=https://mamot.fr/@jdrouet target=_blank> <span class="icon icon-mastodon"></span>@jdrouet</a></nav><div class=job-status><span class=job-status-dot>‚óè</span><span class=job-status-text> Open to new opportunities - <a href=https://www.linkedin.com/in/jeremiedrouet target=_blank>Let's connect on LinkedIn</a> or <a href=mailto:hire@jdrouet.fr>contact me</a> </span></div></div></header><div class=container><main><article class=page><div class=header-container><h2>ü¶Ä Building a search engine from scratch, in Rust: part 1</h2></div><div class=page-info><div class="page-tags mb-1em">Tags = [ <a class=page-tag href=/tags/rust/>rust</a>, <a class=page-tag href=/tags/search-engine/>search-engine</a>, <a class=page-tag href=/tags/webassembly/>webassembly</a>, <a class=page-tag href=/tags/encryption/>encryption</a>, <a class=page-tag href=/tags/cross-platform/>cross-platform</a>, <a class=page-tag href=/tags/tutorial/>tutorial</a>, <a class=page-tag href=/tags/performance/>performance</a> ]</div><time class="page-time smaller" datetime=2025-03-22T00:00:00+00:00> Posted on 2025-03-22 </time></div><div class=entry><p>In the <a href=../202503161800-search-engine-intro/>previous article</a>, I introduced what project we're going to address in the following weeks: how to build a cross-platform search engine with encryption capabilities. Today, we'll have a look at the first technical challenge: how to store things on disk.<p>You might be thinking that we start with a simple topic, to warm up and get ready for the serious parts. That's both right and wrong at the same time. Writing on the filesystem from a mobile application or a desktop application is an easy task, but doing so in the browser while using the same interface is not as easy as it seems.<p>And on top of that, we want our storage layer to read and write encrypted files, without compromising too much on performance.<h2 id=the-storage-challenge>The Storage Challenge</h2><p>Before diving into search algorithms and indexing, we need to solve a fundamental challenge: how do we store data consistently across different platforms? While writing to the filesystem is straightforward on desktop and mobile platforms, browsers present unique constraints that require careful consideration.<p><strong>Key Challenges:</strong><ul><li>Cross-platform filesystem access<li>Async operations requirement<li>Performance considerations<li>Encryption integration (coming up next)</ul><h2 id=exploring-available-solutions>Exploring Available Solutions</h2><p>When I first approached this problem, I naturally looked at what the browser ecosystem offers for storage. The most obvious solution seemed to be <a href=https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage rel=noopener target=_blank>LocalStorage</a> - it's simple, widely supported, and easy to use. However, its limitations quickly became apparent: the storage size is restricted (usually to just a few megabytes), and it only supports string values, which would force us to serialize and deserialize our data constantly.<p>Next, I considered <a href=https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API rel=noopener target=_blank>IndexedDB</a>. It's more powerful and supports larger datasets, which initially seemed promising. But working with <a href=https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API rel=noopener target=_blank>IndexedDB</a> directly is notoriously complex - its API is verbose and requires handling multiple edge cases. While there are wrapper libraries that make it more palatable, they would add unnecessary bulk to our final bundle size.<p>That's when I discovered the <a href=https://developer.mozilla.org/en-US/docs/Web/API/File_System_API rel=noopener target=_blank>File System API</a>, a relatively new addition to modern browsers. This API caught my attention because it provides something remarkable: a filesystem-like interface that feels natural and familiar. Instead of working with abstract storage concepts, we can work with files and directories in a way that's conceptually similar to how we'd handle storage on desktop or mobile platforms.<p>The <a href=https://developer.mozilla.org/en-US/docs/Web/API/File_System_API rel=noopener target=_blank>File System API</a> offers several compelling advantages:<ul><li>We can work with files directly, making our code more intuitive<li>Performance is generally better than alternatives since we're closer to the system<li>The API aligns well with how we'll handle storage on other platforms<li>We get proper file handling capabilities including streaming and random access</ul><p>However, there's a catch - browsers isolate this filesystem access to a specific directory for security reasons. We can't just access any file on the user's system (which is actually good for our use case). Also, the API is relatively new, which means we need to consider browser compatibility.<p><strong>Key Points:</strong><ul><li>LocalStorage is too limited in size and capabilities<li>IndexedDB is powerful but complex and heavy<li>File System API provides the best balance of features and simplicity<li>We'll need to handle the async nature of browser storage<li>Security constraints actually benefit our use case</ul><p>Let's dive into how we can work with this API in practice...<h2 id=storage-layer>Storage layer</h2><p>Considering the browser will be the weak point here, let's spend some time figuring out how to address this.<h3 id=a-filesystem-for-the-browser>A filesystem for the Browser</h3><p>Addressing this head down could lead us to use the <a href=https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage rel=noopener target=_blank>local storage</a> or <a href=https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API rel=noopener target=_blank>IndexedDB</a> as a virtual filesystem. But modern browsers now come with a <a href=https://developer.mozilla.org/en-US/docs/Web/API/File_System_API rel=noopener target=_blank>File System API</a> that provides an access to the filesystem on the device. This API doesn't provide a direct access to <code>/home</code> or any other directory, but instead, provides an isolated directory in which it's possible to do any kind of filesystem operation (expect links).<p>After taking a look at the documentation, here is how it works in javascript<pre class=language-javascript data-lang=javascript style=color:#cccece;background-color:#2b2c2f><code class=language-javascript data-lang=javascript><span style=color:#5f6364>// we get access to the isolated directory for our page
</span><span style=color:#c594c5>const </span><span>root </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>await </span><span style=color:#69c>navigator</span><span style=color:#5fb3b3>.</span><span>storage</span><span style=color:#5fb3b3>.</span><span style=color:#69c>getDirectory</span><span>()</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// we open a file
</span><span style=color:#c594c5>const </span><span>draftHandle </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>await </span><span style=color:#69c>root</span><span style=color:#5fb3b3>.</span><span style=color:#69c>getFileHandle</span><span>(</span><span style=color:#5fb3b3>"</span><span style=color:#99c794>draft.txt</span><span style=color:#5fb3b3>", { </span><span>create</span><span style=color:#5fb3b3>: </span><span style=color:#f99157>true </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>// we write to the file
</span><span style=color:#c594c5>const </span><span>encoder </span><span style=color:#5fb3b3>= new </span><span>TextEncoder()</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>encodedMessage </span><span style=color:#5fb3b3>= </span><span>encoder</span><span style=color:#5fb3b3>.</span><span style=color:#69c>encode</span><span>(message)</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>const </span><span>writeBuffer </span><span style=color:#5fb3b3>= </span><span>accessHandle</span><span style=color:#5fb3b3>.</span><span style=color:#69c>write</span><span>(encodedMessage</span><span style=color:#5fb3b3>, { </span><span>at</span><span style=color:#5fb3b3>: </span><span>readBuffer </span><span style=color:#5fb3b3>}</span><span>)</span><span style=color:#5fb3b3>;
</span></code></pre><p>With this piece of code, there's one thing that's introduced: the storage layer will have to be <code>async</code>.<h4 id=existing-crates>Existing crates</h4><p>After looking on <a href=https://crates.io rel=noopener target=_blank>crates.io</a>, I encountered the nice <a href=https://crates.io/crates/web-fs rel=noopener target=_blank>web-fs</a> crate. The creator promotes the use of <a href=https://crates.io/crates/web-fs rel=noopener target=_blank>web-fs</a> as an wasm alternative for <a href=https://crates.io/crates/async-fs rel=noopener target=_blank>async-fs</a>. With a simple <code>#[cfg(target_arch = "wasm32")]</code>, one can switch from one implementation or the other.<p>But after trying things out and digging a bit more in the code itself, something surprised me. Most of the filesystem operations are offloaded to a separate web worker, which is fair considering the <code>createSyncAccessHandle()</code> <a href=https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/createSyncAccessHandle rel=noopener target=_blank>method</a> is only available in a dedicated web worker.<p>Taking a step back here: would I run a search engine, that does some heavy operations in the main thread? I'd probably have a dedicated web worker doing everything. So this abstraction level is therefore not needed anybody, making things simpler.<h4 id=implementing-a-simple-wrapper>Implementing a simple wrapper</h4><p>Implementing the <a href=https://developer.mozilla.org/en-US/docs/Web/API/File_System_API rel=noopener target=_blank>File System API</a> wrapper in rust is quite an easy task considering <a href=https://crates.io/crates/web-sys rel=noopener target=_blank>web-sys</a> already extracts most of the javascript API to Rust.<p>Here is now how to get the root directory directly in Rust<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>// getting the worker scope
</span><span style=color:#c594c5>let</span><span> scope </span><span style=color:#5fb3b3>= </span><span>js_sys</span><span style=color:#5fb3b3>::</span><span>global</span><span style=color:#5fb3b3>().</span><span>unchecking_into</span><span style=color:#5fb3b3>::<</span><span>WorkerGlobalScope</span><span style=color:#5fb3b3>>();
</span><span style=color:#5f6364>// getting the storage manager
</span><span style=color:#c594c5>let</span><span> manager </span><span style=color:#5fb3b3>=</span><span> scope</span><span style=color:#5fb3b3>.</span><span style=color:#69c>navigator</span><span style=color:#5fb3b3>().</span><span style=color:#69c>storage</span><span style=color:#5fb3b3>();
</span><span style=color:#5f6364>// getting the root directory
</span><span style=color:#c594c5>let</span><span> root </span><span style=color:#5fb3b3>= </span><span>JsFuture</span><span style=color:#5fb3b3>::</span><span>from</span><span style=color:#5fb3b3>(</span><span>manager</span><span style=color:#5fb3b3>.</span><span style=color:#69c>get_directory</span><span style=color:#5fb3b3>())
</span><span>    </span><span style=color:#5fb3b3>.</span><span>await
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span>dyn_into</span><span style=color:#5fb3b3>::<</span><span>FileSystemDirectoryHandle</span><span style=color:#5fb3b3>>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>();
</span></code></pre><p>Starting from this, we can create a file and write into it<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>// definiting the options for opening the file
</span><span style=color:#5f6364>// surprisingly, no need to be mutable
</span><span style=color:#c594c5>let</span><span> opts </span><span style=color:#5fb3b3>= </span><span>FileSystemGetFileOptions</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>();
</span><span>opts</span><span style=color:#5fb3b3>.</span><span style=color:#69c>set_create</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>true</span><span style=color:#5fb3b3>);
</span><span style=color:#c594c5>let</span><span> promise </span><span style=color:#5fb3b3>=</span><span> root</span><span style=color:#5fb3b3>.</span><span style=color:#69c>get_file_handle_with_options</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>draft.txt</span><span style=color:#5fb3b3>", &</span><span>opts</span><span style=color:#5fb3b3>);
</span><span style=color:#c594c5>let</span><span> file </span><span style=color:#5fb3b3>= </span><span>JsFuture</span><span style=color:#5fb3b3>::</span><span>from</span><span style=color:#5fb3b3>(</span><span>promise</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span>await
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span>dyn_into</span><span style=color:#5fb3b3>::<</span><span>FileSystemFileHandle</span><span style=color:#5fb3b3>>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>();
</span><span style=color:#5f6364>// creating an access handle
</span><span style=color:#c594c5>let</span><span> promise </span><span style=color:#5fb3b3>=</span><span> file</span><span style=color:#5fb3b3>.</span><span style=color:#69c>create_sync_access_handle</span><span style=color:#5fb3b3>();
</span><span style=color:#c594c5>let</span><span> access </span><span style=color:#5fb3b3>= </span><span>JsFuture</span><span style=color:#5fb3b3>::</span><span>from</span><span style=color:#5fb3b3>(</span><span>promise</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span>await
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span>dyn_into</span><span style=color:#5fb3b3>::</span><span>FileSystemSyncAccessHandle</span><span style=color:#5fb3b3><>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>();
</span></code></pre><p>This is how simple the <a href=https://developer.mozilla.org/en-US/docs/Web/API/File_System_API rel=noopener target=_blank>File System API</a> can be accessed.<p>This <code>FileSystemSyncAccessHandle</code> provides the capability to read and write from/at any point in the file. Starting from this, it's now possible to implement <a href=https://docs.rs/futures-io/0.3.31/futures_io/trait.AsyncRead.html rel=noopener target=_blank><code>AsyncRead</code></a>, <a href=https://docs.rs/futures-io/0.3.31/futures_io/trait.AsyncSeek.html rel=noopener target=_blank><code>AsyncSeek</code></a> and <a href=https://docs.rs/futures-io/0.3.31/futures_io/trait.AsyncWrite.html rel=noopener target=_blank><code>AsyncWrite</code></a> which gives all the capabilities to implement the storage layer.<p>I'm not going to elaborate more about this, it's probably enough already, but if you're interested about its implementation, I've made a crate out of it, <a href=https://crates.io/crates/browser-fs rel=noopener target=_blank>browser-fs</a>, that can be used like <code>web-fs</code>, but without the overhead.<h3 id=merging-the-different-implementations>Merging The Different Implementations</h3><p>Now that there is a way to write to the filesystem from any platform, creating a module for accessing the filesystem will be as simple as<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5fb3b3>#[</span><span>cfg</span><span style=color:#5fb3b3>(</span><span>target_arch </span><span style=color:#5fb3b3>= "</span><span style=color:#99c794>wasm32</span><span style=color:#5fb3b3>")]
</span><span style=color:#c594c5>use </span><span>browser_fs</span><span style=color:#5fb3b3>::*;
</span><span style=color:#5fb3b3>#[</span><span>cfg</span><span style=color:#5fb3b3>(</span><span style=color:#69c>not</span><span style=color:#5fb3b3>(</span><span style=color:#69c>target_arch </span><span style=color:#5fb3b3>= "</span><span style=color:#99c794>wasm32</span><span style=color:#5fb3b3>"))]
</span><span style=color:#c594c5>use </span><span>async_fs</span><span style=color:#5fb3b3>::*;
</span></code></pre><h2 id=the-encryption-layer>The Encryption Layer</h2><p>I started with a quite simple question: how do we encrypt data efficiently without compromising security? After evaluating several options, I landed on <a href=https://en.wikipedia.org/wiki/Galois/Counter_Mode rel=noopener target=_blank><code>aes-gcm</code></a> (AES Galois/Counter Mode). This choice wasn't random, AES-GCM gives us two crucial guarantees: our data stays confidential and we can verify its authenticity. Plus, the <a href=https://crates.io/crates/aes-gcm rel=noopener target=_blank>aes-gcm</a> crate provides a battle-tested implementation we can trust.<p>I initially considered implementing streaming encryption, which would let us read and write encrypted content directly on the filesystem. It seemed elegant on paper - why load entire files into memory when we could stream them? But as I dug deeper, I realized I was potentially overcomplicating things. Here's why:<ol><li>Implementing streaming encryption with both authenticity and confidentiality is tricky<li>Making it play nice with async operations would add even more complexity<li>Given our use case (small index files optimized for mobile sync), the benefits wouldn't justify the complexity</ol><p>What sealed the deal for me was discovering that modern browsers support AES-GCM through their <a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API rel=noopener target=_blank>Web Crypto API</a>. This means we could potentially offload encryption tasks to the browser's native implementation, saving both processing power and WASM bundle size.<h3 id=the-cipher-implementation>The Cipher Implementation</h3><p>Let's walk through how I built the encryption layer. First, we need a way to carry our cipher around. Since we'll be using it across different file instances and possibly different threads, we want something that's both clone-able and thread-safe:<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>use </span><span>std</span><span style=color:#5fb3b3>::</span><span>sync</span><span style=color:#5fb3b3>::</span><span>Arc</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5fb3b3>#[</span><span>derive</span><span style=color:#5fb3b3>(</span><span>Clone</span><span style=color:#5fb3b3>)]
</span><span style=color:#c594c5>pub struct </span><span>Cipher</span><span style=color:#5fb3b3>(</span><span>Arc</span><span style=color:#5fb3b3><</span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>Aes256Gcm</span><span style=color:#5fb3b3>>);
</span></code></pre><p>Now, how do we create new ciphers? We need a way to initialize them with a key. Here's what I came up with:<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>Cipher </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>from_key</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>input</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>Self</span><span>, Error</span><span style=color:#5fb3b3>> {
</span><span>        aes_gcm</span><span style=color:#5fb3b3>::</span><span>Aes256Gcm</span><span style=color:#5fb3b3>::</span><span>new_from_slice</span><span style=color:#5fb3b3>(</span><span>input</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>inner</span><span style=color:#5fb3b3>| </span><span style=color:#c594c5>Self</span><span style=color:#5fb3b3>(</span><span>Arc</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>(</span><span>inner</span><span style=color:#5fb3b3>)))
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span>_</span><span style=color:#5fb3b3>| </span><span>Error</span><span style=color:#5fb3b3>::</span><span>InvalidKeyLength</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>The interesting part comes with encryption and decryption. AES-GCM requires a unique <code>nonce</code> (number used once) for each message. Instead of asking users to manage nonces themselves, which would be error-prone, I decided to generate a new one for each encryption and prefix it to the encrypted data. This way, decryption becomes straightforward as the nonce is right there in the data:<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>Cipher </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>encrypt</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>input</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#5f6364>// Each encryption gets its own 96-bit nonce
</span><span>        </span><span style=color:#c594c5>let</span><span> nonce </span><span style=color:#5fb3b3>= </span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>Aes256Gcm</span><span style=color:#5fb3b3>::</span><span>generate_nonce</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut</span><span> OsRng</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#c594c5>let</span><span> ciphertext </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#f99157>0
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>encrypt</span><span style=color:#5fb3b3>(&</span><span>nonce</span><span style=color:#5fb3b3>,</span><span> input</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span>_</span><span style=color:#5fb3b3>| </span><span>Error</span><span style=color:#5fb3b3>::</span><span>EncryptionFailed</span><span style=color:#5fb3b3>)?;
</span><span>
</span><span>        </span><span style=color:#5f6364>// We pack the nonce with the encrypted data
</span><span>        </span><span style=color:#c594c5>let mut</span><span> result </span><span style=color:#5fb3b3>=</span><span> nonce</span><span style=color:#5fb3b3>.</span><span style=color:#69c>to_vec</span><span style=color:#5fb3b3>();
</span><span>        result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>extend</span><span style=color:#5fb3b3>(</span><span>ciphertext</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span>result</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>decrypt</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>input</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#5f6364>// First 12 bytes are our nonce
</span><span>        </span><span style=color:#c594c5>let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>((</span><span>nonce</span><span style=color:#5fb3b3>,</span><span> payload</span><span style=color:#5fb3b3>)) =</span><span> input</span><span style=color:#5fb3b3>.</span><span style=color:#69c>split_at_checked</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>12</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>return </span><span style=color:#fac863>Err</span><span style=color:#5fb3b3>(</span><span>Error</span><span style=color:#5fb3b3>::</span><span>DecryptionFailed</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>};
</span><span>
</span><span>        </span><span style=color:#c594c5>let</span><span> nonce </span><span style=color:#5fb3b3>= </span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>Nonce</span><span style=color:#5fb3b3>::<</span><span>U12</span><span style=color:#5fb3b3>>::</span><span>from_slice</span><span style=color:#5fb3b3>(</span><span>nonce</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#f99157>0.</span><span style=color:#69c>decrypt</span><span style=color:#5fb3b3>(</span><span>nonce</span><span style=color:#5fb3b3>,</span><span> payload</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span>_</span><span style=color:#5fb3b3>| </span><span>Error</span><span style=color:#5fb3b3>::</span><span>DecryptionFailed</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Putting it all together with proper error handling, here's our complete encryption solution:<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>use </span><span>std</span><span style=color:#5fb3b3>::</span><span>sync</span><span style=color:#5fb3b3>::</span><span>Arc</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>use </span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>aead</span><span style=color:#5fb3b3>::</span><span>consts</span><span style=color:#5fb3b3>::</span><span>U12</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>use </span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>aead</span><span style=color:#5fb3b3>::{</span><span>Aead</span><span style=color:#5fb3b3>,</span><span> OsRng</span><span style=color:#5fb3b3>};
</span><span style=color:#c594c5>use </span><span>aes_gcm</span><span style=color:#5fb3b3>::{</span><span>AeadCore</span><span style=color:#5fb3b3>,</span><span> KeyInit</span><span style=color:#5fb3b3>};
</span><span>
</span><span style=color:#c594c5>pub enum </span><span>Error </span><span style=color:#5fb3b3>{
</span><span>    InvalidKeyLength</span><span style=color:#5fb3b3>,
</span><span>    EncryptionFailed</span><span style=color:#5fb3b3>,
</span><span>    DecryptionFailed</span><span style=color:#5fb3b3>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5fb3b3>#[</span><span>derive</span><span style=color:#5fb3b3>(</span><span>Clone</span><span style=color:#5fb3b3>)]
</span><span style=color:#c594c5>pub struct </span><span>Cipher</span><span style=color:#5fb3b3>(</span><span>Arc</span><span style=color:#5fb3b3><</span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>Aes256Gcm</span><span style=color:#5fb3b3>>);
</span><span>
</span><span style=color:#c594c5>impl </span><span>Cipher </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>from_key</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>input</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>Self</span><span>, Error</span><span style=color:#5fb3b3>> {
</span><span>        aes_gcm</span><span style=color:#5fb3b3>::</span><span>Aes256Gcm</span><span style=color:#5fb3b3>::</span><span>new_from_slice</span><span style=color:#5fb3b3>(</span><span>input</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>inner</span><span style=color:#5fb3b3>| </span><span style=color:#c594c5>Self</span><span style=color:#5fb3b3>(</span><span>Arc</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>(</span><span>inner</span><span style=color:#5fb3b3>)))
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span>_</span><span style=color:#5fb3b3>| </span><span>Error</span><span style=color:#5fb3b3>::</span><span>InvalidKeyLength</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>encrypt</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>input</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#5f6364>// Each encryption gets its own 96-bit nonce
</span><span>        </span><span style=color:#c594c5>let</span><span> nonce </span><span style=color:#5fb3b3>= </span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>Aes256Gcm</span><span style=color:#5fb3b3>::</span><span>generate_nonce</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut</span><span> OsRng</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#c594c5>let</span><span> ciphertext </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#f99157>0.</span><span style=color:#69c>encrypt</span><span style=color:#5fb3b3>(&</span><span>nonce</span><span style=color:#5fb3b3>,</span><span> input</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span>_</span><span style=color:#5fb3b3>| </span><span>Error</span><span style=color:#5fb3b3>::</span><span>EncryptionFailed</span><span style=color:#5fb3b3>)?;
</span><span>        </span><span style=color:#5f6364>// We pack the nonce with the encrypted data
</span><span>        </span><span style=color:#c594c5>let mut</span><span> result </span><span style=color:#5fb3b3>=</span><span> nonce</span><span style=color:#5fb3b3>.</span><span style=color:#69c>to_vec</span><span style=color:#5fb3b3>();
</span><span>        result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>extend</span><span style=color:#5fb3b3>(</span><span>ciphertext</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span>result</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>decrypt</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>input</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#5f6364>// First 12 bytes are our nonce
</span><span>        </span><span style=color:#c594c5>let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>((</span><span>nonce</span><span style=color:#5fb3b3>,</span><span> payload</span><span style=color:#5fb3b3>)) =</span><span> input</span><span style=color:#5fb3b3>.</span><span style=color:#69c>split_at_checked</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>12</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>return </span><span style=color:#fac863>Err</span><span style=color:#5fb3b3>(</span><span>Error</span><span style=color:#5fb3b3>::</span><span>DecryptionFailed</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>};
</span><span>
</span><span>        </span><span style=color:#c594c5>let</span><span> nonce </span><span style=color:#5fb3b3>= </span><span>aes_gcm</span><span style=color:#5fb3b3>::</span><span>Nonce</span><span style=color:#5fb3b3>::<</span><span>U12</span><span style=color:#5fb3b3>>::</span><span>from_slice</span><span style=color:#5fb3b3>(</span><span>nonce</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#f99157>0.</span><span style=color:#69c>decrypt</span><span style=color:#5fb3b3>(</span><span>nonce</span><span style=color:#5fb3b3>,</span><span> payload</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span>_</span><span style=color:#5fb3b3>| </span><span>Error</span><span style=color:#5fb3b3>::</span><span>DecryptionFailed</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This encryption layer might seem simple, but it's intentionally so. It provides strong security guarantees while remaining easy to use and understand. When building complex systems, I've learned that simple, well-understood solutions often outperform clever but complicated ones.<h2 id=wrapping-things-up>Wrapping Things Up</h2><p>Now that we can write on the filesystem and encrypt the data, let's write a piece of code that plug them both together. But to do so, we need to define what will be written or what hierarchy it will have.<h3 id=the-file-trait>The File Trait</h3><p>Let's stay open minded here, considering this is the early stage of the implementation. We need to consider that we need to store encrypted files, but maybe some clear files as well, for things what wouldn't be at risk.<p>If we start with a simple item, let's define what a file should look like.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>trait </span><span>File </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>write</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>payload</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -></span><span> impl Future</span><span style=color:#5fb3b3><</span><span>Output = std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()>>;
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>read</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -></span><span> impl Future</span><span style=color:#5fb3b3><</span><span>Output = std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>>>>;
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>delete</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -></span><span> impl Future</span><span style=color:#5fb3b3><</span><span>Output = std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()>>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Where, when using an unencrypted file, we get the following<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>struct </span><span>ClearFile </span><span style=color:#5fb3b3>{
</span><span>    path</span><span style=color:#5fb3b3>: </span><span>std</span><span style=color:#5fb3b3>::</span><span>path</span><span style=color:#5fb3b3>::</span><span>PathBuf,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>File </span><span style=color:#c594c5>for </span><span>ClearFile </span><span style=color:#5fb3b3>{
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>write</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>payload</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()> {
</span><span>        fs</span><span style=color:#5fb3b3>::</span><span>write</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>,</span><span> payload</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>read</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>>> {
</span><span>        fs</span><span style=color:#5fb3b3>::</span><span>read</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>delete</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()> {
</span><span>        fs</span><span style=color:#5fb3b3>::</span><span>delete</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>And the encrypted file is slightly more complicated<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>struct </span><span>EncryptedFile </span><span style=color:#5fb3b3>{
</span><span>    path</span><span style=color:#5fb3b3>: </span><span>std</span><span style=color:#5fb3b3>::</span><span>path</span><span style=color:#5fb3b3>::</span><span>PathBuf,
</span><span>    cipher</span><span style=color:#5fb3b3>:</span><span> Cipher,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>File </span><span style=color:#c594c5>for </span><span>ClearFile </span><span style=color:#5fb3b3>{
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>write</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>payload</span><span style=color:#5fb3b3>: &</span><span>[</span><span style=color:#c594c5>u8</span><span>]</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()> {
</span><span>        </span><span style=color:#c594c5>let</span><span> payload </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>cipher</span><span style=color:#5fb3b3>.</span><span style=color:#69c>encrypt</span><span style=color:#5fb3b3>(</span><span>payload</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(</span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span>Error</span><span style=color:#5fb3b3>::</span><span>other</span><span style=color:#5fb3b3>)?;
</span><span>        fs</span><span style=color:#5fb3b3>::</span><span>write</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>, &</span><span>payload</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>read</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#c594c5>let</span><span> content </span><span style=color:#5fb3b3>= </span><span>fs</span><span style=color:#5fb3b3>::</span><span>read</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>cipher</span><span style=color:#5fb3b3>.</span><span style=color:#69c>decrypt</span><span style=color:#5fb3b3>(&</span><span>content</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(</span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span>Error</span><span style=color:#5fb3b3>::</span><span>other</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>delete</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()> {
</span><span>        fs</span><span style=color:#5fb3b3>::</span><span>delete</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>It's now event possible to extend the <code>File</code> trait to make it more practical and add serialization support.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>trait </span><span>File </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>// keep the other trait functions here
</span><span>
</span><span>    </span><span style=color:#5f6364>// Serialize and write a value to the file
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>serialize</span><span style=color:#5fb3b3><</span><span>V</span><span style=color:#5fb3b3>: </span><span>serde</span><span style=color:#5fb3b3>::</span><span>Serialize</span><span style=color:#5fb3b3>>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>: &</span><span>V</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()> {
</span><span>        </span><span style=color:#c594c5>let</span><span> payload </span><span style=color:#5fb3b3>= </span><span>serde_cbor</span><span style=color:#5fb3b3>::</span><span>to_vec</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>).</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>err</span><span style=color:#5fb3b3>| {
</span><span>            std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span>Error</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>(</span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span>ErrorKind</span><span style=color:#5fb3b3>::</span><span>InvalidData</span><span style=color:#5fb3b3>,</span><span> err</span><span style=color:#5fb3b3>)
</span><span>        </span><span style=color:#5fb3b3>})?;
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>write</span><span style=color:#5fb3b3>(&</span><span>payload</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#5f6364>/// Read and deserialize a value from the file
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>deserialize</span><span style=color:#5fb3b3><</span><span>V</span><span style=color:#5fb3b3>: </span><span>serde</span><span style=color:#5fb3b3>::</span><span>de</span><span style=color:#5fb3b3>::</span><span>DeserializeOwned</span><span style=color:#5fb3b3>>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span>V</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let</span><span> content </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>read</span><span style=color:#5fb3b3>().</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>        serde_cbor</span><span style=color:#5fb3b3>::</span><span>from_slice</span><span style=color:#5fb3b3>(&</span><span>content</span><span style=color:#5fb3b3>).</span><span style=color:#69c>map_err</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>err</span><span style=color:#5fb3b3>| {
</span><span>            std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span>Error</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>(</span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span>ErrorKind</span><span style=color:#5fb3b3>::</span><span>InvalidData</span><span style=color:#5fb3b3>,</span><span> err</span><span style=color:#5fb3b3>)
</span><span>        </span><span style=color:#5fb3b3>})
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>You can see in the code above that I'm using <a href=https://crates.io/crates/serde_cbor rel=noopener target=_blank><code>serde_cbor</code></a>: this is for simplicity and for performance, you can keep whichever you prefer.<h3 id=directory-management>Directory Management</h3><p>Now that we have file operations, let's write something at the directory level that provides us ways to create instances of <code>ClearFile</code> or <code>EncryptedFile</code>.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>struct </span><span>Directory </span><span style=color:#5fb3b3>{
</span><span>    cipher</span><span style=color:#5fb3b3>:</span><span> Cipher,
</span><span>    path</span><span style=color:#5fb3b3>: </span><span>std</span><span style=color:#5fb3b3>::</span><span>path</span><span style=color:#5fb3b3>::</span><span>PathBuf,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>Directory </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// creates a new instance of a ClearFile, without creating it on the filesystem
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>clear_file</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>relative</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>AsRef</span><span style=color:#5fb3b3><</span><span>Path</span><span style=color:#5fb3b3>>) -></span><span> ClearFile </span><span style=color:#5fb3b3>{
</span><span>        ClearFile </span><span style=color:#5fb3b3>{
</span><span>            path</span><span style=color:#5fb3b3>: </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span style=color:#5fb3b3>(</span><span>relative</span><span style=color:#5fb3b3>),
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#5f6364>/// creates a new instance of a EncryptedFile, without creating it on the filesystem
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>encrypted_file</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>relative</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>AsRef</span><span style=color:#5fb3b3><</span><span>Path</span><span style=color:#5fb3b3>>) -></span><span> EncryptedFile </span><span style=color:#5fb3b3>{
</span><span>        EncryptedFile </span><span style=color:#5fb3b3>{
</span><span>            path</span><span style=color:#5fb3b3>: </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>.</span><span style=color:#69c>join</span><span style=color:#5fb3b3>(</span><span>relative</span><span style=color:#5fb3b3>),
</span><span>            cipher</span><span style=color:#5fb3b3>: </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>cipher</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>(),
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>And if we add some extra functions to do basics operations on the directory, like listing files, creating the directory or deleting the directory and its content<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>Directory </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// creates the directory if not exists
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>create</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()> {
</span><span>        fs</span><span style=color:#5fb3b3>::</span><span>create_dir_all</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#5f6364>/// list all the files in the current directory
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>files</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span>PathBuf</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#c594c5>use </span><span>futures_lite</span><span style=color:#5fb3b3>::</span><span>StreamExt</span><span style=color:#5fb3b3>;
</span><span>
</span><span>        </span><span style=color:#c594c5>let mut</span><span> result </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>if let </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>mut</span><span> res</span><span style=color:#5fb3b3>) = </span><span>fs</span><span style=color:#5fb3b3>::</span><span>read_dir</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>).</span><span>await </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>while let </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>item</span><span style=color:#5fb3b3>)) =</span><span> res</span><span style=color:#5fb3b3>.</span><span style=color:#69c>try_next</span><span style=color:#5fb3b3>().</span><span>await </span><span style=color:#5fb3b3>{
</span><span>                </span><span style=color:#c594c5>let</span><span> filepath </span><span style=color:#5fb3b3>=</span><span> item</span><span style=color:#5fb3b3>.</span><span style=color:#69c>path</span><span style=color:#5fb3b3>();
</span><span>                </span><span style=color:#c594c5>if</span><span> filepath</span><span style=color:#5fb3b3>.</span><span style=color:#69c>is_file</span><span style=color:#5fb3b3>() {
</span><span>                    result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span style=color:#5fb3b3>(</span><span>filepath</span><span style=color:#5fb3b3>);
</span><span>                </span><span style=color:#5fb3b3>}
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>
</span><span>        </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span>result</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#5f6364>/// removes the current directory and all its content
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>delete</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()> {
</span><span>        fs</span><span style=color:#5fb3b3>::</span><span>remove_dir_all</span><span style=color:#5fb3b3>(&</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>path</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>At this point, we have everything we need to interact with the filesystem, read and write files, drop files and handle the working directory of the search engine.<h2 id=conclusion>Conclusion</h2><p>In this first part of this series on building a search engine, we've laid a solid foundation by addressing one of the most fundamental challenges: cross-platform storage with encryption support. We've successfully created:<ul><li>A unified storage interface that works across desktop, mobile, and browser platforms<li>An efficient encryption layer using AES-GCM that provides both security and authenticity<li>A clean API that abstracts away the complexities of different filesystems and encryption</ul><p>The resulting implementation is not just functional, but also maintainable and extensible. By choosing the <a href=https://developer.mozilla.org/en-US/docs/Web/API/File_System_API rel=noopener target=_blank>File System API</a> for browser storage and implementing a straightforward encryption layer, we've avoided unnecessary complexity while maintaining strong security guarantees.<p>This storage layer will serve as the backbone for our search engine, allowing us to reliably store and retrieve indexed data across all platforms. In the next article, we'll build upon this foundation to start implementing the core indexing functionality of our search engine.<p>Stay tuned for the next part where we'll dive into the exciting world of search algorithms and index structures!</div><div class=page-footer><a href="https://github.com/jdrouet/jdrouet.github.io/blob/main/content/posts/202503170800-search-engine-part-1.md?plain=1" title="Help improve page /posts/202503170800-search-engine-part-1/" target=_blank>Suggest improvements</a></div></article></main></div><footer><a alt="Send me an email" class=text-xxl href=mailto:contact@jdrouet.fr target=_blank> <i class="icon icon-mail"></i> </a><a alt="My GitHub profile" class=text-xxl href=https://github.com/jdrouet target=_blank> <i class="icon icon-github"></i> </a><a alt="My LinkedIn profile" class=text-xxl href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <i class="icon icon-linkedin"></i> </a><a alt="Follow me on Mamot" class=text-xxl href=https://mamot.fr/@jdrouet target=_blank> <i class="icon icon-mastodon"></i> </a><a alt="Follow my RSS feed" class=text-xxl href=/atom.xml target=_blank> <i class="icon icon-rss"></i> </a><span class=copyright>¬© 2023 - 2025 J√©r√©mie Drouet</span></footer>