<!doctype html><html lang=en-US xml:lang=en-US><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="text/html;charset=utf-8" http-equiv=Content-Type><link href=/favicon.svg rel=icon type=image/svg><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/main.css rel=stylesheet><meta content=#151515 name=theme-color><meta content=#151515 name=msapplication-navbutton-color><meta content=black-translucent name=apple-mobile-web-app-status-bar-style><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>jdrouet > Building a search engine from scratch, in Rust: introduction</title><meta content=Zola name=generator><meta content="Or how to build a secure, blazingly fast search engine that works everywhere, from your browser to your phone, without compromising on features or performance." name=description><meta content="J√©r√©mie Drouet" name=author><link href=/posts/202503161800-search-engine-intro/ rel=canonical><meta content="Building a search engine from scratch, in Rust: introduction" property=og:title><meta content="Or how to build a secure, blazingly fast search engine that works everywhere, from your browser to your phone, without compromising on features or performance." property=og:description><meta content=article property=og:type><meta content=/posts/202503161800-search-engine-intro/ property=og:url><meta content=/images/logo.png property=og:image><meta content=jdrouet property=og:site_name><meta content=en_US property=og:locale><meta content=2025-03-16T00:00:00+00:00 property=article:published_time><body><header><div class=container><a href=/ id=a-title> <h1>üßë‚Äçüíª jdrouet</h1> </a><h2>My projects, my thoughts and other things.</h2><nav id=navbar><a alt="Link to Home" class=btn href=/> Home </a><a alt="Link to LinkedIn profile" class=btn href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <span class="icon icon-linkedin"></span>About me</a><a alt="Link to GitHub profile" class=btn href=https://github.com/jdrouet target=_blank> <span class="icon icon-github"></span>jdrouet</a><a alt="Link to Mastodon profile" class=btn href=https://mamot.fr/@jdrouet target=_blank> <span class="icon icon-mastodon"></span>@jdrouet</a></nav><div class=job-status><span class=job-status-dot>‚óè</span><span class=job-status-text> Open to new opportunities - <a href=https://www.linkedin.com/in/jeremiedrouet target=_blank>Let's connect on LinkedIn</a> or <a href=mailto:hire@jdrouet.fr>contact me</a> </span></div></div></header><div class=container><main><article class=page><div class=header-container><h2>ü¶Ä Building a search engine from scratch, in Rust: introduction</h2></div><div class=page-info><div class="page-tags mb-1em">Tags = [ <a class=page-tag href=/tags/rust/>rust</a>, <a class=page-tag href=/tags/search-engine/>search-engine</a>, <a class=page-tag href=/tags/webassembly/>webassembly</a>, <a class=page-tag href=/tags/encryption/>encryption</a>, <a class=page-tag href=/tags/cross-platform/>cross-platform</a>, <a class=page-tag href=/tags/tutorial/>tutorial</a>, <a class=page-tag href=/tags/performance/>performance</a> ]</div><time class="page-time smaller" datetime=2025-03-16T00:00:00+00:00> Posted on 2025-03-16 </time></div><div class=entry><p>Have you ever wondered how search engines work under the hood? I'm not talking about vector search or anything fancy, but just the good old search engines that could really find what we would look for. Even though we can already find some articles about how search engine work from a high level, it could be interesting to implement our own and add some constraints to make it fun (and maybe simpler).<h2 id=the-challenge>The Challenge</h2><p>Most search engine implementations you'll find online target the server-side. They're great for large-scale applications but don't address the unique challenges of building a search engine that runs directly in your browser, your mobile app or in a desktop app. That's exactly what we're going to tackle: creating a client-side search engine that works seamlessly across platforms. And to spice things up, we'll add an encryption layer so that the indexed data stays safe and encrypted.<p>Running a search engine in a browser brings its own set of interesting constraints and challenges. We'll need to work within the limitations of WebAssembly, handle browser-specific storage mechanisms, and ensure our engine performs well even with limited resources. But WebAssembly is not the only limiting factor. Running a computation intensive process in a mobile app could be challenging: what happens if the mobile app goes to the background while indexing? These constraints make the project even more interesting from a learning perspective.<p><strong>Main Challenges:</strong><ul><li>Browser limitations (storage, threading)<li>Mobile limitations (limited CPU time)<li>Cross-platform compatibility<li>Resource constraints</ul><h2 id=why-build-from-scratch>Why Build From Scratch?</h2><p>There are several existing solutions we could use. <a href=https://www.meilisearch.com/ rel=noopener target=_blank>Meilisearch</a> and <a href=https://www.elastic.co/elasticsearch rel=noopener target=_blank>Elasticsearch</a> are powerful search engines, but they're designed to run on servers and would not be suitable for client-side search. <a href=https://github.com/quickwit-oss/tantivy rel=noopener target=_blank>Tantivy</a> is an excellent Rust-based search engine that we can draw inspiration from, but its heavy use of threading makes it unsuitable for browser environments. <a href=https://www.sqlite.org/ rel=noopener target=_blank>SQLite</a> with full-text search capabilities could work with <a href=https://github.com/sqlcipher/sqlcipher rel=noopener target=_blank>SQLCipher</a>, but the binary would be big, the persistence layer in the browser would be complicated to implement and we wouldn't learn much how to implement a search engine.<p>Building our own search engine gives us complete control over the architecture and implementation. We can make it exactly as lightweight or feature-rich as we need, and most importantly, we can learn about every component that goes into making a search engine work.<p><strong>Existing Solutions Limitations:</strong><ul><li><a href=https://www.meilisearch.com/ rel=noopener target=_blank>Meilisearch</a>/<a href=https://www.elastic.co/elasticsearch rel=noopener target=_blank>Elasticsearch</a>: Server-focused<li><a href=https://github.com/quickwit-oss/tantivy rel=noopener target=_blank>Tantivy</a>: Not browser-compatible<li><a href=https://www.sqlite.org/ rel=noopener target=_blank>SQLite</a> and <a href=https://github.com/sqlcipher/sqlcipher rel=noopener target=_blank>SQLCipher</a>: Limited search capabilities</ul><h2 id=project-goals>Project Goals</h2><p>Our search engine needs to work seamlessly across different platforms. Whether it's running in a web browser through WebAssembly, in a mobile application, or on the desktop, the core functionality should remain consistent. This cross-platform requirement introduces interesting challenges in handling platform-specific quirks while maintaining a unified codebase.<p>Resource efficiency is crucial, especially when running in a browser environment. We need to keep our memory footprint small, ensure our binary size doesn't bloat the application, and maintain snappy search performance. These constraints will push us to make thoughtful design decisions and optimizations.<p>We'll support various data types in our search engine. From basic text content to tags, numbers, and boolean values, each type brings its own indexing and searching challenges. We'll implement flexible querying capabilities that allow users to search across these different types effectively.<p>As an interesting twist, we'll add encryption capabilities to our engine. While not strictly necessary for a basic search engine, implementing encryption adds an extra layer of complexity and learning opportunity. It's a great way to understand how encryption can be integrated into a search system while keeping performance in mind.<p>To finish, in order to not compute our indexes on every platforms we'll run the search engine, we'll make the encrypted indexes sharable between devices.<p><strong>Core Features:</strong><ul><li>Cross-platform compatibility<li>Multiple data type support<li>Efficient resource usage<li>Encryption<li>Index synchronization between devices</ul><h2 id=high-level-architecture-overview>High-Level Architecture Overview</h2><p>Here's a glimpse of what we'll be building:<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// The main search engine interface
</span><span style=color:#c594c5>pub trait </span><span>SearchEngine </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// Index a new document
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>index</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>document</span><span style=color:#5fb3b3>:</span><span> Document</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()>;
</span><span>    </span><span style=color:#5f6364>/// Search through indexed documents
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>query</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span>SearchResults</span><span style=color:#5fb3b3>>;
</span><span>    </span><span style=color:#5f6364>/// Delete a document from the index
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>delete</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>id</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><()>;
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Our engine will be built in layers, starting with basic storage operations with the encryption layer, then adding indexing capabilities, the search functionality, and, finally, how to synchronize those indexes between devices. This modular approach will help us understand each component's role and how they work together to create a functioning search engine.<p><strong>Architecture Layers:</strong><ul><li>Storage: File operations and data persistence, with encryption<li>Index: Document management and retrieval<li>Search: Query processing and results<li>Synchronization: Sharing the computed indexes across devices</ul><h2 id=the-journey-ahead>The Journey Ahead</h2><p>Throughout this series, we'll explore every aspect of building a search engine. We'll start with the fundamentals of storage and work our way up to complex search algorithms. Along the way, we'll tackle cross-platform challenges, optimize performance, and add encryption capabilities.<p>Next up, we'll dive into implementing the storage layer, where we'll face our first cross-platform challenges and lay the groundwork for our search engine. We'll explore different storage strategies for browsers and native applications, and begin adding our cryptographic spice to the mix.<p><strong>Series Outline:</strong><ul><li>Part 0: Introduction (this article)<li><a href=../202503170800-search-engine-part-1/>Part 1: Storage Layer Implementation</a><li><a href=../202503191700-search-engine-part-2/>Part 2: Document Schema and Indexes</a><li><a href=../202503231000-search-engine-part-3/>Part 3: Sharding and Transactions</a><li><a href=../202503311500-search-engine-part-4/>Part 4: Search Implementation</a><li>Part 5: Performance Optimization<li>Part 6: Index Synchronization</ul><p>Stay tuned for the next article in this series, where we'll get our hands dirty with actual implementation. Whether you're a seasoned Rust developer or just getting started, this journey promises to be both educational and entertaining.</div><div class=page-footer><a href="https://github.com/jdrouet/jdrouet.github.io/blob/main/content/posts/202503161800-search-engine-intro.md?plain=1" title="Help improve page /posts/202503161800-search-engine-intro/" target=_blank>Suggest improvements</a></div></article></main></div><footer><a alt="Send me an email" class=text-xxl href=mailto:contact@jdrouet.fr target=_blank> <i class="icon icon-mail"></i> </a><a alt="My GitHub profile" class=text-xxl href=https://github.com/jdrouet target=_blank> <i class="icon icon-github"></i> </a><a alt="My LinkedIn profile" class=text-xxl href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <i class="icon icon-linkedin"></i> </a><a alt="Follow me on Mamot" class=text-xxl href=https://mamot.fr/@jdrouet target=_blank> <i class="icon icon-mastodon"></i> </a><a alt="Follow my RSS feed" class=text-xxl href=/atom.xml target=_blank> <i class="icon icon-rss"></i> </a><span class=copyright>¬© 2023 - 2025 J√©r√©mie Drouet</span></footer>