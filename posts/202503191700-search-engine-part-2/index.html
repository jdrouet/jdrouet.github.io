<!doctype html><html lang=en-US xml:lang=en-US><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="text/html;charset=utf-8" http-equiv=Content-Type><link href=/favicon.svg rel=icon type=image/svg><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/main.css rel=stylesheet><meta content=#151515 name=theme-color><meta content=#151515 name=msapplication-navbutton-color><meta content=black-translucent name=apple-mobile-web-app-status-bar-style><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>jdrouet > Building a search engine from scratch, in Rust: part 2</title><meta content=Zola name=generator><meta content="Or how we'll go from a set of documents to a set of structured indexes." name=description><meta content="J√©r√©mie Drouet" name=author><link href=/posts/202503191700-search-engine-part-2/ rel=canonical><meta content="Building a search engine from scratch, in Rust: part 2" property=og:title><meta content="Or how we'll go from a set of documents to a set of structured indexes." property=og:description><meta content=article property=og:type><meta content=/posts/202503191700-search-engine-part-2/ property=og:url><meta content=/images/logo.png property=og:image><meta content=jdrouet property=og:site_name><meta content=en_US property=og:locale><meta content=2025-03-28T00:00:00+00:00 property=article:published_time><body><header><div class=container><a href=/ id=a-title> <h1>üßë‚Äçüíª jdrouet</h1> </a><h2>My projects, my thoughts and other things.</h2><nav id=navbar><a alt="Link to Home" class=btn href=/> Home </a><a alt="Link to LinkedIn profile" class=btn href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <span class="icon icon-linkedin"></span>About me</a><a alt="Link to GitHub profile" class=btn href=https://github.com/jdrouet target=_blank> <span class="icon icon-github"></span>jdrouet</a><a alt="Link to Mastodon profile" class=btn href=https://mamot.fr/@jdrouet target=_blank> <span class="icon icon-mastodon"></span>@jdrouet</a></nav><div class=job-status><span class=job-status-dot>‚óè</span><span class=job-status-text> Open to new opportunities - <a href=https://www.linkedin.com/in/jeremiedrouet target=_blank>Let's connect on LinkedIn</a> or <a href=mailto:hire@jdrouet.fr>contact me</a> </span></div></div></header><div class=container><main><article class=page><div class=header-container><h2>ü¶Ä Building a search engine from scratch, in Rust: part 2</h2></div><div class=page-info><div class="page-tags mb-1em">Tags = [ <a class=page-tag href=/tags/rust/>rust</a>, <a class=page-tag href=/tags/search-engine/>search-engine</a>, <a class=page-tag href=/tags/webassembly/>webassembly</a>, <a class=page-tag href=/tags/encryption/>encryption</a>, <a class=page-tag href=/tags/cross-platform/>cross-platform</a>, <a class=page-tag href=/tags/tutorial/>tutorial</a>, <a class=page-tag href=/tags/performance/>performance</a> ]</div><time class="page-time smaller" datetime=2025-03-28T00:00:00+00:00> Posted on 2025-03-28 </time></div><div class=entry><p>In the <a href=../202503170800-search-engine-part-1/>previous article</a>, I explained how we'll write on disk and how we'll implement an abstraction so that it works on any device as well as in the browser. Now, it's time to think about what we'll store and in what format.<h2 id=defining-a-document>Defining A Document</h2><p>In the majority of time, the use of a search engine is coupled with a database, because it's rarely the search-engine responsibility to store the document. The database stores the things and the search-engine indexes the important attributes that need to be searched on. Indexing content is memory intensive so better not abuse it.<p>The consequence of this it that the document that are being indexed, most of the time, have a defined structure, a schema that they follow.<p>If we look at an example of search engine like <a href=https://github.com/quickwit-oss/tantivy rel=noopener target=_blank>Tantivy</a>, indexing a document requires the definition of a schema. Using a similar pattern here seems fairly legit.<p>On the other side, if we look at <a href=https://www.elastic.co/elasticsearch rel=noopener target=_blank>Elasticsearch</a>, the data structure is a bit more free. An indexed document can contain some nested attributes that are then flattened when being indexed. This means that the cardinality of attributes is almost infinite. This works well when you work on a server with a huge about of RAM and a big CPU, but when it comes to the browser on an old mobile, it's better to give it some limitations.<p>That being said, a use case has to be considered: if a document has tags (like the names of the recipients of a message), it would be great to be able to search through them without having to define <code>n</code> independent attributes. To avoid this, it should support arrays.<p>Now, to optimize querying later and avoid querying with some integers an attribute that contains only text, the schema should be aware of the type of an attribute.<p>So let's write down some ground rules:<ul><li>a schema has a finite number of attributes<li>an attribute has a defined attribute<li>a document attribute cannot contain another document<li>a document attribute can contain multiple values</ul><p>If we follow those rules, we should end up with the following API<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>let</span><span> schema </span><span style=color:#5fb3b3>= </span><span>Schema</span><span style=color:#5fb3b3>::</span><span>builder</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>content</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Text</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>sender</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Tag</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>recipient</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Tag</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>timestamp</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Integer</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>encrypted</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Boolean</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>build</span><span style=color:#5fb3b3>();
</span><span>
</span><span style=color:#c594c5>let</span><span> message </span><span style=color:#5fb3b3>= </span><span>Document</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>message_id</span><span style=color:#5fb3b3>")
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>content</span><span style=color:#5fb3b3>", "</span><span style=color:#99c794>Hello World!</span><span style=color:#5fb3b3>") </span><span style=color:#5f6364>// text
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>sender</span><span style=color:#5fb3b3>", "</span><span style=color:#99c794>Alice</span><span style=color:#5fb3b3>") </span><span style=color:#5f6364>// tag
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>recipient</span><span style=color:#5fb3b3>", "</span><span style=color:#99c794>Bob</span><span style=color:#5fb3b3>") </span><span style=color:#5f6364>// tag
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>recipient</span><span style=color:#5fb3b3>", "</span><span style=color:#99c794>Charles</span><span style=color:#5fb3b3>") </span><span style=color:#5f6364>// multiple times the same attribute
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>timestamp</span><span style=color:#5fb3b3>", </span><span style=color:#f99157>123456789</span><span style=color:#5fb3b3>) </span><span style=color:#5f6364>// integer
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>encrypted</span><span style=color:#5fb3b3>", </span><span style=color:#f99157>true</span><span style=color:#5fb3b3>); </span><span style=color:#5f6364>// boolean
</span></code></pre><p>This is a fairly simple implementation.<p>Now, in <a href=../202503161800-search-engine-intro/>the introduction</a>, it was mentioned that the content of the index should be sharded. Sharding means we have to define a way to group documents. As a matter of simplicity, the sharding mechanism will be just based on an integer attribute defined in the document but if you want to look at more complex mechanism, I'll invite you to have a look at how <a href=https://www.postgresql.org/docs/current/ddl-partitioning.html rel=noopener target=_blank>PostgreSql does it</a>.<p>This is something that should be defined in the schema, so that it's common across the entire search engine. So let's introduce a function to define it as follow.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>let</span><span> schema </span><span style=color:#5fb3b3>= </span><span>Schema</span><span style=color:#5fb3b3>::</span><span>builder</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>content</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Text</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>sender</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Tag</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>recipient</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Tag</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>timestamp</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Integer</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>encrypted</span><span style=color:#5fb3b3>", </span><span>Kind</span><span style=color:#5fb3b3>::</span><span>Boolean</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>shard_by</span><span style=color:#5fb3b3>("</span><span style=color:#99c794>timestamp</span><span style=color:#5fb3b3>")
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>build</span><span style=color:#5fb3b3>()?;
</span></code></pre><p>And now, building the schema should fail if the sharding attribute is not defined or if it's not an <code>integer</code>.<p>It gives us the following structure for the schema.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// Represents the possible data types that can be indexed
</span><span style=color:#c594c5>enum </span><span>Kind </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// Simple true/false values
</span><span>    Boolean</span><span style=color:#5fb3b3>,
</span><span>    </span><span style=color:#5f6364>/// Unsigned 64-bit integers, used for numeric queries and sharding
</span><span>    Integer</span><span style=color:#5fb3b3>,
</span><span>    </span><span style=color:#5f6364>/// Single tokens that require exact matching (e.g. email addresses, IDs)
</span><span>    Tag</span><span style=color:#5fb3b3>,
</span><span>    </span><span style=color:#5f6364>/// Full-text content that will be tokenized and stemmed
</span><span>    Text</span><span style=color:#5fb3b3>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>/// Defines the structure and rules for indexable documents
</span><span style=color:#c594c5>struct </span><span>Schema </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// Maps attribute names to their types
</span><span>    attributes</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span>, Kind</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5f6364>/// The attribute used to determine document sharding
</span><span>    </span><span style=color:#5f6364>/// Must be of Kind::Integer
</span><span>    shard_by</span><span style=color:#5fb3b3>:</span><span> String,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>Schema </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>// let's follow the builder pattern
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>builder</span><span style=color:#5fb3b3>() -></span><span> SchemaBuilder </span><span style=color:#5fb3b3>{
</span><span>        SchemaBuilder</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>enum </span><span>Error </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// when the user didn't specify a sharding attribute
</span><span>    ShardingAttributeNotSet</span><span style=color:#5fb3b3>,
</span><span>    </span><span style=color:#5f6364>/// when the user specified how to shard but the attribute is not defined
</span><span>    UnknownShardingAttribute
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5fb3b3>#[</span><span>derive</span><span style=color:#5fb3b3>(</span><span>Default</span><span style=color:#5fb3b3>)]
</span><span style=color:#c594c5>struct </span><span>SchemaBuilder </span><span style=color:#5fb3b3>{
</span><span>    attributes</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span>, Kind</span><span style=color:#5fb3b3>></span><span>,
</span><span>    shard_by</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>SchemaBuilder </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>name</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>Into</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span style=color:#5fb3b3>></span><span>, </span><span style=color:#f99157>kind</span><span style=color:#5fb3b3>:</span><span> Kind</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>Self </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>attributes</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>into</span><span style=color:#5fb3b3>(),</span><span> kind</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#ec5f67>self
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>shard_by</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>name</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>Into</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span style=color:#5fb3b3>>) -> </span><span style=color:#c594c5>Self </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>shard_by </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>into</span><span style=color:#5fb3b3>());
</span><span>        </span><span style=color:#ec5f67>self
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>build</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span>Schema, Error</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>shard_by</span><span style=color:#5fb3b3>) = </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>shard_by </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>return </span><span style=color:#fac863>Err</span><span style=color:#5fb3b3>(</span><span>Error</span><span style=color:#5fb3b3>::</span><span>ShardingAttributeNotSet</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#c594c5>if </span><span style=color:#5fb3b3>!</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>attributes</span><span style=color:#5fb3b3>.</span><span style=color:#69c>contains_key</span><span style=color:#5fb3b3>(&</span><span>shard_by</span><span style=color:#5fb3b3>) {
</span><span>            </span><span style=color:#c594c5>return </span><span style=color:#fac863>Err</span><span style=color:#5fb3b3>(</span><span>Error</span><span style=color:#5fb3b3>::</span><span>UnknownShardingAttribute</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>
</span><span>        </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span>Schema </span><span style=color:#5fb3b3>{
</span><span>            attributes</span><span style=color:#5fb3b3>: </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>attributes</span><span style=color:#5fb3b3>,
</span><span>            shard_by</span><span style=color:#5fb3b3>,
</span><span>        </span><span style=color:#5fb3b3>})
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p><strong>Note:</strong> if we want to optimize some extra bytes, instead of using a <code>String</code>, we can use a <code>Box&LTstr></code> as we won't update the content of those strings.<p>Now, let's have a look at the <code>Document</code> API. we could create a document builder that will analyse every attribute value that gets inserted in the document, but this could become a bit complicated to handle all the possible errors that should never happen.<p>Instead of that, the search-engine will validate the document before inserting it in the indexes.<p>This gives use a relatively simple API for the <code>Document</code> as well.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// A value that can be indexed
</span><span style=color:#c594c5>enum </span><span>Value </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// Boolean values are stored as-is
</span><span>    Boolean</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>bool</span><span style=color:#5fb3b3>),
</span><span>    </span><span style=color:#5f6364>/// Integer values are used for range queries and sharding
</span><span>    Integer</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>u64</span><span style=color:#5fb3b3>),
</span><span>    </span><span style=color:#5f6364>/// Tags are stored without any processing
</span><span>    Tag</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>String</span><span style=color:#5fb3b3>),
</span><span>    </span><span style=color:#5f6364>/// Text values will be tokenized and processed
</span><span>    Text</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>String</span><span style=color:#5fb3b3>),
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>/// Represents a document to be indexed
</span><span style=color:#c594c5>struct </span><span>Document </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// Unique identifier for the document
</span><span>    id</span><span style=color:#5fb3b3>:</span><span> String,
</span><span>    </span><span style=color:#5f6364>/// Maps attribute names to their values
</span><span>    </span><span style=color:#5f6364>/// A single attribute can have multiple values
</span><span>    attributes</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span>, </span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span>Value</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>Document </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>new</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>id</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>Into</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span style=color:#5fb3b3>>) -> </span><span style=color:#c594c5>Self </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>Self </span><span style=color:#5fb3b3>{
</span><span>            id</span><span style=color:#5fb3b3>:</span><span> id</span><span style=color:#5fb3b3>.</span><span style=color:#69c>into</span><span style=color:#5fb3b3>(),
</span><span>            attributes</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Default</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>(),
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>pub fn </span><span style=color:#69c>attribute</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>name</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>Into</span><span style=color:#5fb3b3><</span><span style=color:#fac863>String</span><span style=color:#5fb3b3>></span><span>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>Into</span><span style=color:#5fb3b3><</span><span>Value</span><span style=color:#5fb3b3>>) -> </span><span style=color:#c594c5>Self </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>attributes</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>into</span><span style=color:#5fb3b3>()).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>().</span><span style=color:#69c>push</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>.</span><span style=color:#69c>into</span><span style=color:#5fb3b3>());
</span><span>        </span><span style=color:#ec5f67>self
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This kind of API provides the flexibility to build any kind of attribute without having to think too much about the errors and then handle the validation when it gets inserted. The schema being fixed, this kind of errors should be covered by the users tests, by doing so, I decided to prioritise usability.<p>Now that we have defined our schema and document structure, here's how all the pieces fit together:<pre class=language-ascii data-lang=ascii style=color:#cccece;background-color:#2b2c2f><code class=language-ascii data-lang=ascii><span>+-------------+     +----------------+
</span><span>| Document    |     | Collection     |
</span><span>+-------------+     +----------------+
</span><span>| id: String  |     | entries_by_idx |
</span><span>| attributes  +---->| entries_by_name|
</span><span>+-------------+     | sharding       |
</span><span>                    +----------------+
</span><span>                           |
</span><span>                           v
</span><span>        +----------------------------------+
</span><span>        |           Indexes                |
</span><span>        |----------------------------------|
</span><span>        |                                  |
</span><span>    +--------+   +---------+   +--------+  |
</span><span>    |Boolean |   |Integer  |   |Text    |  |
</span><span>    |Index   |   |Index    |   |Index   |  |
</span><span>    +--------+   +---------+   +--------+  |
</span><span>        |            |            |        |
</span><span>        +------------+------------+--------+
</span></code></pre><p>Key takeaways:<ul><li>Documents have a fixed schema with typed attributes<li>Supported types: Boolean, Integer, Tag, Text<li>Documents can have multiple values for an attribute<li>Sharding is based on an integer attribute<li>Schema validation happens at document insertion</ul><h2 id=destructuring-the-documents>Destructuring The Documents</h2><p>Now that we know how the documents will be structured, it's time to dive in the serious stuff: the indexes.<p>The indexes will contain the information we need to find a document based on the query parameters. We'll try to keep the content of the index fairly small when serialized to maximise the content of indexed data.<p>So basically, we'll do a link between the data and the document identifier: from a given term (boolean, integer, tag or text), what document contains that term, and how many times. A basic data structure would look like this.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>type </span><span>Index </span><span style=color:#5fb3b3>= </span><span>Map</span><span style=color:#5fb3b3><</span><span>Term, Map</span><span style=color:#5fb3b3><</span><span>DocumentIdentifier, Count</span><span style=color:#5fb3b3>>>;
</span></code></pre><p>This would be reproduced across every index and term. When you think about the <code>DocumentIdentifier</code>, which would be a <code>String</code>, each term would have a cost of <a href=https://doc.rust-lang.org/std/mem/fn.size_of.html rel=noopener target=_blank><code>size_of(DocumentIdentifier)</code></a> which is <strong>at least</strong> equal to the size of the string (plus some bytes depending on if we use <code>String</code> or <code>Box&LTstr></code>). This doesn't scale well for large documents containing many terms and big identifiers, we need to use a different approach.<h3 id=the-collection-file>The Collection File</h3><p>If we introduce, for each shard, a <code>Collection</code> file that will contain a list of all the document identifiers and a <code>u32</code> to identify them, then in each index, we can use that <code>u32</code> to identify the document.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>type </span><span>EntryIndex </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u32</span><span style=color:#5fb3b3>;
</span><span style=color:#5f6364>/// the collection file in each shard
</span><span style=color:#c594c5>type </span><span>Collection </span><span style=color:#5fb3b3>= </span><span>Map</span><span style=color:#5fb3b3><</span><span>EntryIndex, DocumentIdentifier</span><span style=color:#5fb3b3>>;
</span><span style=color:#5f6364>/// for each index type
</span><span style=color:#c594c5>type </span><span>Index </span><span style=color:#5fb3b3>= </span><span>Map</span><span style=color:#5fb3b3><</span><span>Term, Map</span><span style=color:#5fb3b3><</span><span>EntryIndex, Count</span><span style=color:#5fb3b3>>>;
</span></code></pre><p>This should reduce the cost significantly.<p>Now, in order to shard the collections and indexes, we need to store the attribute used for sharding close. If we use the index to find the sharding value of every document, considering the structure of the index, doing so will not be performant enough.<p>Persisting that attribute in the collection should make it easier to access.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>type </span><span>EntryIndex </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u32</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>type </span><span>ShardingValue </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u64</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>struct </span><span>Collection </span><span style=color:#5fb3b3>{
</span><span>    entries</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, DocumentIdentifier</span><span style=color:#5fb3b3>></span><span>,
</span><span>    sharding</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span>ShardingValue, HashSet</span><span style=color:#5fb3b3><</span><span>EntryIndex</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>That way, when one of our indexes reaches a critical size, we can just split in half the shard by taking all the entries based on the sharding <code>BTreeMap</code>. The <code>BTreeMap</code>, being sorted by design, provides the perfect API for that.<p>The next problem we'll have to tackle on that structure: when deleting a document from the index, how to efficiently go from the <code>DocumentIdentifier</code> to the <code>EntryIndex</code>? For that, we need to introduce a reverse map as follow.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>type </span><span>EntryIndex </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u32</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>type </span><span>ShardingValue </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u64</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>struct </span><span>Collection </span><span style=color:#5fb3b3>{
</span><span>    entries_by_index</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, DocumentIdentifier</span><span style=color:#5fb3b3>></span><span>,
</span><span>    entries_by_name</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>DocumentIdentifier, EntryIndex</span><span style=color:#5fb3b3>></span><span>,
</span><span>    sharding</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span>ShardingValue, HashSet</span><span style=color:#5fb3b3><</span><span>EntryIndex</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This improves the performance for getting an entry by name, but duplicates all the document identifiers on disk. We can do better by doing that duplication when serializing or deserializing our collection.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>type </span><span>EntryIndex </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u32</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>type </span><span>ShardingValue </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u64</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>type </span><span>DocumentIdentifier </span><span style=color:#5fb3b3>= </span><span>Arc</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>;
</span><span>
</span><span style=color:#5f6364>/// Representation on disk of an entry
</span><span style=color:#c594c5>struct </span><span>Entry </span><span style=color:#5fb3b3>{
</span><span>    index</span><span style=color:#5fb3b3>:</span><span> EntryIndex,
</span><span>    name</span><span style=color:#5fb3b3>:</span><span> DocumentIdentifier,
</span><span>    shard</span><span style=color:#5fb3b3>:</span><span> ShardingValue,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>/// Representation on disk of a collection
</span><span style=color:#c594c5>struct </span><span>PersistedCollection </span><span style=color:#5fb3b3>{
</span><span>    entries</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span>Entry</span><span style=color:#5fb3b3>>
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This represents how we'll store our collection on disk. Each entry maintains its numeric index, document identifier, and sharding value in a simple vector structure.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// Manages document identifiers and sharding information
</span><span style=color:#c594c5>struct </span><span>Collection </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// Maps numeric indexes to document identifiers
</span><span>    </span><span style=color:#5f6364>/// Uses u32 to optimize memory usage while supporting large datasets
</span><span>    entries_by_index</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, DocumentIdentifier</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5f6364>/// Reverse mapping for quick document lookups
</span><span>    entries_by_name</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>DocumentIdentifier, EntryIndex</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5f6364>/// Maps sharding values to sets of document indexes
</span><span>    </span><span style=color:#5f6364>/// Using BTreeMap for ordered access during shard splitting
</span><span>    sharding</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span>ShardingValue, HashSet</span><span style=color:#5fb3b3><</span><span>EntryIndex</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>In memory, we maintain bidirectional mappings between indexes and document identifiers for efficient lookups in both directions. The sharding map uses a <code>BTreeMap</code> to maintain order, which will be crucial for our sharding operations.<p>And here is the function to build a <code>Collection</code> based on its persisted state on disk.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// Let's build the collection from the persisted state
</span><span style=color:#c594c5>impl </span><span style=color:#fac863>From</span><span style=color:#5fb3b3><</span><span>PersistedCollection</span><span style=color:#5fb3b3>> </span><span style=color:#c594c5>for </span><span>Collection </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>from</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>:</span><span> PersistedCollection</span><span style=color:#5fb3b3>) -></span><span> Collection </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>let mut</span><span> entries_by_index </span><span style=color:#5fb3b3>= </span><span>HashMap</span><span style=color:#5fb3b3>::</span><span>with_capacity</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>.</span><span>entries</span><span style=color:#5fb3b3>.</span><span style=color:#69c>len</span><span style=color:#5fb3b3>());
</span><span>        </span><span style=color:#c594c5>let mut</span><span> entries_by_name </span><span style=color:#5fb3b3>= </span><span>HashMap</span><span style=color:#5fb3b3>::</span><span>with_capacity</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>.</span><span>entries</span><span style=color:#5fb3b3>.</span><span style=color:#69c>len</span><span style=color:#5fb3b3>());
</span><span>        </span><span style=color:#c594c5>let mut</span><span> sharding </span><span style=color:#5fb3b3>= </span><span>BTreeMap</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>for</span><span> entry </span><span style=color:#5fb3b3>in</span><span> value</span><span style=color:#5fb3b3>.</span><span>entries </span><span style=color:#5fb3b3>{
</span><span>            entries_by_index</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>entry</span><span style=color:#5fb3b3>.</span><span>index</span><span style=color:#5fb3b3>,</span><span> entry</span><span style=color:#5fb3b3>.</span><span>name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>());
</span><span>            entries_by_name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>entry</span><span style=color:#5fb3b3>.</span><span>name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>(),</span><span> entry</span><span style=color:#5fb3b3>.</span><span>index</span><span style=color:#5fb3b3>);
</span><span>            sharding</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>entry</span><span style=color:#5fb3b3>.</span><span>shard</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>().</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>entry</span><span style=color:#5fb3b3>.</span><span>index</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>        Collection </span><span style=color:#5fb3b3>{
</span><span>            entries_by_index</span><span style=color:#5fb3b3>,
</span><span>            entries_by_name</span><span style=color:#5fb3b3>,
</span><span>            sharding</span><span style=color:#5fb3b3>,
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Notice the use of <a href=https://doc.rust-lang.org/std/sync/struct.Arc.html rel=noopener target=_blank><code>Arc&LTstr></code></a> instead of <code>String</code>. We need to have multiple reference to the same string in memory. If we use <code>String</code>, we'll pay several time the cost of that string length. When using <code>Arc&LTstr></code>, we only pay the price of the string length once and just the price of the pointer each time we clone it.<blockquote><p>One could ask, considering the advantage of <code>Arc&LTstr></code>, why not writing that directly to disk or use it in the other indexes. Well, it doesn't work when serialized. <a href=https://doc.rust-lang.org/std/sync/struct.Arc.html rel=noopener target=_blank><code>Arc&LTstr></code></a> contains a pointer in memory of where the string is. When serialize/deserialize, this memory address changes, so the serializer just replaces the pointer with its actual value, which means duplication of data.</blockquote><p>Now, let's take a step back. In the current <code>Index</code> representation, there's no mention of attribute, but the attribute is quite similar to the document identifier: we don't know how big it could be and the size on disk is related to the size of the string. Might be worst adding it in our collection structure. And since we'll need to access the attribute name by an <code>AttributeIndex</code> and the other way around, we need to implement a similar mechanism.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// Let's keep a fairly low number of attributes, 256 attributes should be enough
</span><span style=color:#c594c5>type </span><span>AttributeIndex </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>struct </span><span>Attribute </span><span style=color:#5fb3b3>{
</span><span>    index</span><span style=color:#5fb3b3>:</span><span> AttributeIndex,
</span><span>    name</span><span style=color:#5fb3b3>: </span><span>Arc</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>struct </span><span>PersistedCollection </span><span style=color:#5fb3b3>{
</span><span>    attributes</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span>Attribute</span><span style=color:#5fb3b3>></span><span>,
</span><span>    entries</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><</span><span>Entry</span><span style=color:#5fb3b3>>
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>struct </span><span>Collection </span><span style=color:#5fb3b3>{
</span><span>    attributes_by_index</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, Arc</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    attributes_by_name</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>Arc</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>></span><span>, AttributeIndex</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5f6364>// ...other fields
</span><span style=color:#5fb3b3>}
</span></code></pre><p>At this point, we have everything ween need to build our collection.<p>Key points about collections:<ul><li>Uses numeric indexes to reduce storage overhead<li>Maintains bidirectional mappings for efficient lookups<li>Stores sharding information for easy partitioning<li>Uses <code>Arc&LTstr></code> for memory-efficient string handling<li>Attributes are also indexed for space optimization</ul><p>Before we dive into each index type, here's how the hierarchical structure works for our indexes:<pre class=language-ascii data-lang=ascii style=color:#cccece;background-color:#2b2c2f><code class=language-ascii data-lang=ascii><span>Term Index
</span><span>+---------+
</span><span>|'rust'   |--+
</span><span>|'fast'   |  |
</span><span>|'search' |  |
</span><span>+---------+  |
</span><span>             v
</span><span>        Attribute Index
</span><span>        +-------------+
</span><span>        |'content'    |--+
</span><span>        |'title'      |  |
</span><span>        +-------------+  |
</span><span>                         v
</span><span>                    Document Index
</span><span>                    +------------+
</span><span>                    |Doc1: [0,5] |
</span><span>                    |Doc2: [3]   |
</span><span>                    +------------+
</span></code></pre><h3 id=boolean-index>Boolean Index</h3><p>Now let's start with a simple index, the boolean index. This will only have simple use cases: fetching the entries where an attribute is <code>true</code> or <code>false</code>.<p>So if we follow the structure we defined earlier, we'd end up with the following tructure.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>type </span><span>ValueIndex </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#5f6364>/// stores boolean values for quick true/false queries
</span><span style=color:#c594c5>struct </span><span>BooleanIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// maps boolean values to their postings
</span><span>    </span><span style=color:#5f6364>/// structure: bool -> attribute -> document -> value positions
</span><span>    content</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>bool</span><span>, HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, HashSet</span><span style=color:#5fb3b3><</span><span>ValueIndex</span><span style=color:#5fb3b3>>>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Where <code>ValueIndex</code> is the index of that term, for an attribute, for that entry.<p>That way, inserting a value can be done this way.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>BooleanIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(
</span><span>        </span><span style=color:#5fb3b3>&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>,
</span><span>        </span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>:</span><span> EntryIndex,
</span><span>        </span><span style=color:#f99157>attribute_index</span><span style=color:#5fb3b3>:</span><span> AttributeIndex,
</span><span>        </span><span style=color:#f99157>value_index</span><span style=color:#5fb3b3>:</span><span> ValueIndex,
</span><span>        </span><span style=color:#f99157>term</span><span style=color:#5fb3b3>: </span><span style=color:#c594c5>bool</span><span>,
</span><span>    </span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>let</span><span> term_postings </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> attribute_postings </span><span style=color:#5fb3b3>=</span><span> term_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>attribute_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> entry_postings </span><span style=color:#5fb3b3>=</span><span> attribute_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>        entry_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>value_index</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>For deletion, we get the following implementation<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>BooleanIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>delete</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>:</span><span> EntryIndex</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>let mut</span><span> changed </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>false</span><span style=color:#5fb3b3>;
</span><span>        </span><span style=color:#c594c5>for </span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>,</span><span> term_postings</span><span style=color:#5fb3b3>) in </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter_mut</span><span style=color:#5fb3b3>() {
</span><span>            </span><span style=color:#c594c5>for </span><span style=color:#5fb3b3>(</span><span>attribute</span><span style=color:#5fb3b3>,</span><span> attribute_postings</span><span style=color:#5fb3b3>) in</span><span> term_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter_mut</span><span style=color:#5fb3b3>() {
</span><span>                changed </span><span style=color:#5fb3b3>|=</span><span> attribute_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&</span><span>entry_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>is_some</span><span style=color:#5fb3b3>();
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>        changed
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This is fairly simple. But there is an invisible problem here: empty postings don't get removed.<p>We could, after each removal, check that the posting is not empty, and if empty, remove it from the parent.<h4 id=self-cleaning-postings>Self Cleaning Postings</h4><p>To avoid doing that in every indexes, writing a trait would make things simpler.<p>First, we need to provide a way for the parent container to know if the posting is empty. Considering there is no trait shared between all the map and set implementations, we should define one.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// Trait to check if an element is empty
</span><span style=color:#c594c5>trait </span><span>IsEmpty </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>is_empty</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl</span><span style=color:#5fb3b3><</span><span>K, V</span><span style=color:#5fb3b3>></span><span> IsEmpty </span><span style=color:#c594c5>for </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>K, V</span><span style=color:#5fb3b3>> {
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>is_empty</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool </span><span style=color:#5fb3b3>{
</span><span>        HashMap</span><span style=color:#5fb3b3>::</span><span>is_empty</span><span style=color:#5fb3b3>(</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>It's also possible to write a macro so that we can implement this on <code>HashMap</code>, <code>HashSet</code>, <code>BTreeMap</code> and all other maps.<p>And now, we can define a trait to have a self cleaning container<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>trait </span><span>WithMut&LTK, V> </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>iter_with_mut</span><span style=color:#5fb3b3><</span><span>Cb</span><span style=color:#5fb3b3>>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>callback</span><span style=color:#5fb3b3>:</span><span> Cb</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool
</span><span>    </span><span style=color:#c594c5>where
</span><span>        Cb</span><span style=color:#5fb3b3>:</span><span> FnMut</span><span style=color:#5fb3b3>((&</span><span>K, </span><span style=color:#5fb3b3>&</span><span style=color:#c594c5>mut</span><span> V</span><span style=color:#5fb3b3>))</span><span> -> </span><span style=color:#c594c5>bool</span><span>;
</span><span>}
</span><span>
</span><span>impl</span><span style=color:#5fb3b3><</span><span>K, V</span><span style=color:#5fb3b3>> </span><span>WithMut</span><span style=color:#5fb3b3><</span><span>K, V</span><span style=color:#5fb3b3>> </span><span style=color:#c594c5>for </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>K, V</span><span style=color:#5fb3b3>>
</span><span style=color:#c594c5>where
</span><span>    K</span><span style=color:#5fb3b3>:</span><span> Clone,
</span><span>    V</span><span style=color:#5fb3b3>:</span><span> IsEmpty,
</span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>iter_with_mut</span><span style=color:#5fb3b3><</span><span>Cb</span><span style=color:#5fb3b3>>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#c594c5>mut </span><span style=color:#f99157>callback</span><span style=color:#5fb3b3>:</span><span> Cb</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool
</span><span>    </span><span style=color:#c594c5>where
</span><span>        cb</span><span style=color:#5fb3b3>:</span><span> FnMut</span><span style=color:#5fb3b3>((&</span><span>K, </span><span style=color:#5fb3b3>&</span><span style=color:#c594c5>mut</span><span> V</span><span style=color:#5fb3b3>))</span><span> -> </span><span style=color:#c594c5>bool
</span><span>    </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>let mut</span><span> keys_to_remove </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> changed </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter_mut</span><span style=color:#5fb3b3>().</span><span style=color:#69c>fold</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>false</span><span style=color:#5fb3b3>, |</span><span style=color:#f99157>acc</span><span style=color:#5fb3b3>, (</span><span style=color:#f99157>key</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>)| {
</span><span>            </span><span style=color:#c594c5>let</span><span> changed </span><span style=color:#5fb3b3>= </span><span style=color:#69c>callback</span><span style=color:#5fb3b3>((</span><span>key</span><span style=color:#5fb3b3>,</span><span> value</span><span style=color:#5fb3b3>));
</span><span>            </span><span style=color:#c594c5>if</span><span> value</span><span style=color:#5fb3b3>.</span><span style=color:#69c>is_empty</span><span style=color:#5fb3b3>() {
</span><span>                </span><span style=color:#5f6364>// we gather all the keys that have to be removed
</span><span>                keys_to_remove</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span style=color:#5fb3b3>(</span><span>key</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>());
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>            acc </span><span style=color:#5fb3b3>||</span><span> changed
</span><span>        </span><span style=color:#5fb3b3>});
</span><span>        </span><span style=color:#5f6364>// we cleanup after giving back the mutability
</span><span>        </span><span style=color:#c594c5>for</span><span> key </span><span style=color:#5fb3b3>in</span><span> keys_to_remove </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&</span><span>key</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>        changed
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>// similar code for HashSet, etc
</span></code></pre><p>And with that fix, the deletion code can be simplified to a way more elegant way<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>BooleanIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>delete</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>:</span><span> EntryIndex</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter_with_mut</span><span style=color:#5fb3b3>(|(</span><span>_</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>term_postings</span><span style=color:#5fb3b3>)| {
</span><span>            term_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter_with_mut</span><span style=color:#5fb3b3>(|(</span><span>_</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>attribute_postings</span><span style=color:#5fb3b3>)| {
</span><span>                attribute_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&</span><span>entry_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>is_some</span><span style=color:#5fb3b3>()
</span><span>            </span><span style=color:#5fb3b3>})
</span><span>        </span><span style=color:#5fb3b3>})
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><h3 id=integer-index>Integer Index</h3><p>Now that we have the boolean index, writing the integer index will be quite trivial. We'll just have a small difference. When on the boolean index we only query <code>true</code> or <code>false</code> for a given attribute, on the integer index, one might want to query for a range, below, above and so on. So the terms should be stored sorted. Luckily, doing so just involves switching a <code>HashMap</code> to become a <code>BTreeMap</code>.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// stores integer values for range queries
</span><span style=color:#c594c5>struct </span><span>IntegerIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// uses BTreeMap for efficient range queries
</span><span>    </span><span style=color:#5f6364>/// structure: number -> attribute -> document -> value positions
</span><span>    content</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u64</span><span>, HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, HashSet</span><span style=color:#5fb3b3><</span><span>ValueIndex</span><span style=color:#5fb3b3>>>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>And that's it, we take the same code as above, and it will work.<h3 id=tag-index>Tag Index</h3><p>Let's pause a bit and clarify something: what's the difference between a tag index and a text index. Well, in this implementation, a tag index is an index where the term, the tag is a single item, that doesn't get preprocessed and that we'll search for as it is. If we insert <code>Alice</code>, then searching <code>alice</code> won't find it, it's only exact match. This is good for matching email addresses, folder names, etc. The text index, on the opposite, the input data gets processed, but we'll talk about it right after.<p>Once again, we can follow a similar architecture than the two other indexes.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// stores tag values for exact matching
</span><span style=color:#c594c5>struct </span><span>TagIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// uses Box&LTstr> to optimize memory usage
</span><span>    </span><span style=color:#5f6364>/// structure: tag -> attribute -> document -> value positions
</span><span>    content</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>></span><span>, HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, HashSet</span><span style=color:#5fb3b3><</span><span>ValueIndex</span><span style=color:#5fb3b3>>>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>You can notice here that, instead of using <code>String</code>, we are using <code>Box&LTstr></code>. This is because the size of a <code>String</code> is of 24 bytes, plus the characters, while <code>Box&LTstr></code> has a size of 16 bytes, plus the characters. This might not seem much, but every byte is worst keeping when you use a Nokia 3310.<h3 id=text-index>Text Index</h3><p>As I mentioned earlier, the text index is a bit more complicated than the tag index. When the tag index is made to return entries that contain a term with exact matching, the text index will provide functionalities to search inside the provided text: the tag index is for a single value like <code>alice</code> or <code>personal</code> while you give the text index complete sentences, articles, documents, etc. And on top of that, we'll want to be able to find some elements in that text even if there are some mistakes in the query: <code>personnal</code> should match documents containing <code>this is a personal document</code>, event with a typo.<p>So we'll have to adjust a bit the interface we used for the other indexes considering now, an input value will carry more information: an indexed attribute value will be composed of several tokens. A token will be defined by its term, it's position in the original text and the index in the list of tokens.<p>Processing that input will consist in extracting the words from the input text, lowercase them and apply some <a href=https://en.wikipedia.org/wiki/Stemming rel=noopener target=_blank>stemming</a> before inserting all the terms in the index. The first ones are fairly simple, but the stemming mechanism can be quite complicated, especially when we consider doing something that handles multiple languages.<p>Here is a simple example of how the preprocessing process should work. I removed the complexity from the <code>capture_all</code> and <code>stem</code> function to make it simpler to read. Those functions will just be the ones provided by the <a href=https://crates.io/crates/regex rel=noopener target=_blank><code>regex</code> crate</a> and the <a href=https://crates.io/crates/rust-stemmers rel=noopener target=_blank><code>rust-stemmers</code> crate</a>.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>let</span><span> input </span><span style=color:#5fb3b3>= "</span><span style=color:#99c794>Hello World! Do you want tomatoes?</span><span style=color:#5fb3b3>";
</span><span style=color:#5f6364>// extracting the words
</span><span style=color:#c594c5>let</span><span> tokens </span><span style=color:#5fb3b3>= </span><span style=color:#69c>capture_all</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>r</span><span style=color:#5fb3b3>"</span><span style=color:#99c794>(\w{3,20})</span><span style=color:#5fb3b3>",</span><span> input</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5f6364>// lowercase them
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(|(</span><span style=color:#f99157>position</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>term</span><span style=color:#5fb3b3>)| (</span><span>position</span><span style=color:#5fb3b3>,</span><span> term</span><span style=color:#5fb3b3>.</span><span style=color:#69c>to_lower_case</span><span style=color:#5fb3b3>()))
</span><span>    </span><span style=color:#5f6364>// keep track of the token index
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>enumerate</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5f6364>// stemming
</span><span>    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(|(</span><span style=color:#f99157>index</span><span style=color:#5fb3b3>,</span><span> (</span><span style=color:#f99157>position</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>term</span><span style=color:#5fb3b3>))|</span><span> Token </span><span style=color:#5fb3b3>{
</span><span>        index</span><span style=color:#5fb3b3>,
</span><span>        position</span><span style=color:#5fb3b3>,
</span><span>        term</span><span style=color:#5fb3b3>: </span><span style=color:#69c>stem</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>),
</span><span>    </span><span style=color:#5fb3b3>}</span><span>)
</span><span>    </span><span style=color:#5fb3b3>.</span><span>collect</span><span style=color:#5fb3b3>::<</span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3><_>>();
</span><span style=color:#5f6364>// should return
</span><span style=color:#5f6364>// { term: "hello", index: 0, position: 0 }
</span><span style=color:#5f6364>// { term: "world", index: 1, position: 6 }
</span><span style=color:#5f6364>// { term: "you", index: 2, position: 16 }
</span><span style=color:#5f6364>// { term: "want", index: 3, position: 20 }
</span><span style=color:#5f6364>// { term: "tomato", index: 4, position: 25 }
</span></code></pre><p>And we'll need to store those positions in the index as well, since a term could occur several time in the same attribute value.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>type </span><span>Position </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u32</span><span style=color:#5fb3b3>;
</span><span style=color:#c594c5>type </span><span>TokenIndex </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>u16</span><span style=color:#5fb3b3>;
</span><span>
</span><span style=color:#c594c5>type </span><span>TermPostings </span><span style=color:#5fb3b3>= </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, AttributePostings</span><span style=color:#5fb3b3>>;
</span><span style=color:#c594c5>type </span><span>AttributePostings </span><span style=color:#5fb3b3>= </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, EntryPostings</span><span style=color:#5fb3b3>>;
</span><span style=color:#c594c5>type </span><span>EntryPostings </span><span style=color:#5fb3b3>= </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>ValueIndex, HashSet</span><span style=color:#5fb3b3><(</span><span>TokenIndex, Position</span><span style=color:#5fb3b3>)>>;
</span><span>
</span><span style=color:#5f6364>/// stores processed text for full-text search
</span><span style=color:#c594c5>struct </span><span>TextIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// maps terms to their positions in documents
</span><span>    </span><span style=color:#5f6364>/// structure: term -> attribute -> document -> value -> (token_index, position)
</span><span>    content</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>></span><span>, TermPostings</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Now, for each attribute value, we keep a <code>HashSet</code> of the <code>TokenIndex</code> and <code>Position</code>.<p>Considering the wasm binary will only be able to handle 4GB of data, the maximum index length of a string would fit in a <code>u32</code> and considering the words have a minimum of 3 characters, using <code>u16</code> to index them should be enough. Therefore, <code>Position</code> and <code>TokenIndex</code> are respectively an alias to <code>u32</code> and <code>u16</code>.<p>Now, if we implement the <code>insert</code> method, it gives us the following.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>TextIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(
</span><span>        </span><span style=color:#5fb3b3>&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>,
</span><span>        </span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>:</span><span> EntryIndex,
</span><span>        </span><span style=color:#f99157>attribute_index</span><span style=color:#5fb3b3>:</span><span> AttributeIndex,
</span><span>        </span><span style=color:#f99157>value_index</span><span style=color:#5fb3b3>:</span><span> ValueIndex,
</span><span>        </span><span style=color:#f99157>term</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>str</span><span>,
</span><span>        </span><span style=color:#f99157>token_index</span><span style=color:#5fb3b3>:</span><span> TokenIndex,
</span><span>        </span><span style=color:#f99157>position</span><span style=color:#5fb3b3>:</span><span> Position,
</span><span>    </span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>bool </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>let</span><span> term_postings </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> attribute_postings </span><span style=color:#5fb3b3>=</span><span> term_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>attribute_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> entry_postings </span><span style=color:#5fb3b3>=</span><span> entry_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> value_postings </span><span style=color:#5fb3b3>=</span><span> attr_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>value_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>        value_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>((</span><span>token_index</span><span style=color:#5fb3b3>,</span><span> position</span><span style=color:#5fb3b3>))
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>The <code>delete</code> method, on the other hand, remains the same.<p>Index implementation summary:<ul><li>Boolean Index: Simple true/false lookups<li>Integer Index: Range-based queries using BTreeMap<li>Tag Index: Exact match lookups with <code>Box&LTstr></code> optimization<li>Text Index: Full-text search with position tracking<li>All indexes implement self-cleaning for empty postings</ul><h2 id=conclusion>Conclusion</h2><p>In this second part of our search engine series, we've laid down the fundamental building blocks for storing and indexing documents. We've created a flexible yet efficient architecture that supports multiple data types while keeping resource constraints in mind.<p><strong>Key Achievements:</strong><ul><li>Defined a clear document schema with type-safe attributes<li>Implemented specialized indexes for different data types: <ul><li>Boolean Index for simple true/false queries<li>Integer Index with range query support<li>Tag Index for exact matching<li>Text Index with position tracking and stemming</ul><li>Optimized memory usage with smart data structures (e.g., <code>Box&LTstr></code> over <code>String</code>)<li>Created self-cleaning mechanisms to maintain index efficiency</ul><p>Our implementation balances functionality with performance, carefully considering the constraints of running in browser environments and on mobile devices. The use of specialized data structures and memory-efficient approaches ensures our search engine remains lightweight while supporting rich functionality.<h3 id=what-s-next>What's Next?</h3><p>In the next part, we'll tackle how to make our search engine scalable through sharding and reliable through transactions.<p>We'll explore:<ul><li>How to split data across multiple shards<li>Implementing a transaction system for safe updates<li>Managing concurrent access to indexes<li>Handling recovery from failures</ul><p>Stay tuned to learn how we'll transform these individual components into a robust, distributed search system!</div><div class=page-footer><a href="https://github.com/jdrouet/jdrouet.github.io/blob/main/content/posts/202503191700-search-engine-part-2.md?plain=1" title="Help improve page /posts/202503191700-search-engine-part-2/" target=_blank>Suggest improvements</a></div></article></main></div><footer><a alt="Send me an email" class=text-xxl href=mailto:contact@jdrouet.fr target=_blank> <i class="icon icon-mail"></i> </a><a alt="My GitHub profile" class=text-xxl href=https://github.com/jdrouet target=_blank> <i class="icon icon-github"></i> </a><a alt="My LinkedIn profile" class=text-xxl href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <i class="icon icon-linkedin"></i> </a><a alt="Follow me on Mamot" class=text-xxl href=https://mamot.fr/@jdrouet target=_blank> <i class="icon icon-mastodon"></i> </a><a alt="Follow my RSS feed" class=text-xxl href=/atom.xml target=_blank> <i class="icon icon-rss"></i> </a><span class=copyright>¬© 2023 - 2025 J√©r√©mie Drouet</span></footer>