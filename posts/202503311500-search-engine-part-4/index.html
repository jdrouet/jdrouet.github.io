<!doctype html><html lang=en-US xml:lang=en-US><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="text/html;charset=utf-8" http-equiv=Content-Type><link href=/favicon.svg rel=icon type=image/svg><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/main.css rel=stylesheet><meta content=#151515 name=theme-color><meta content=#151515 name=msapplication-navbutton-color><meta content=black-translucent name=apple-mobile-web-app-status-bar-style><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>jdrouet > Building a search engine from scratch, in Rust: part 4</title><meta content=Zola name=generator><meta content="Or how we'll find something in all this." name=description><meta content="J√©r√©mie Drouet" name=author><link href=/posts/202503311500-search-engine-part-4/ rel=canonical><meta content="Building a search engine from scratch, in Rust: part 4" property=og:title><meta content="Or how we'll find something in all this." property=og:description><meta content=article property=og:type><meta content=/posts/202503311500-search-engine-part-4/ property=og:url><meta content=/images/logo.png property=og:image><meta content=jdrouet property=og:site_name><meta content=en_US property=og:locale><meta content=2025-04-12T00:00:00+00:00 property=article:published_time><body><header><div class=container><a href=/ id=a-title> <h1>üßë‚Äçüíª jdrouet</h1> </a><h2>My projects, my thoughts and other things.</h2><nav id=navbar><a alt="Link to Home" class=btn href=/> Home </a><a alt="Link to LinkedIn profile" class=btn href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <span class="icon icon-linkedin"></span>About me</a><a alt="Link to GitHub profile" class=btn href=https://github.com/jdrouet target=_blank> <span class="icon icon-github"></span>jdrouet</a><a alt="Link to Mastodon profile" class=btn href=https://mamot.fr/@jdrouet target=_blank> <span class="icon icon-mastodon"></span>@jdrouet</a></nav><div class=job-status><span class=job-status-dot>‚óè</span><span class=job-status-text> Open to new opportunities - <a href=https://www.linkedin.com/in/jeremiedrouet target=_blank>Let's connect on LinkedIn</a> or <a href=mailto:hire@jdrouet.fr>contact me</a> </span></div></div></header><div class=container><main><article class=page><div class=header-container><h2>ü¶Ä Building a search engine from scratch, in Rust: part 4</h2></div><div class=page-info><div class="page-tags mb-1em">Tags = [ <a class=page-tag href=/tags/rust/>rust</a>, <a class=page-tag href=/tags/search-engine/>search-engine</a>, <a class=page-tag href=/tags/webassembly/>webassembly</a>, <a class=page-tag href=/tags/encryption/>encryption</a>, <a class=page-tag href=/tags/cross-platform/>cross-platform</a>, <a class=page-tag href=/tags/tutorial/>tutorial</a>, <a class=page-tag href=/tags/performance/>performance</a> ]</div><time class="page-time smaller" datetime=2025-04-12T00:00:00+00:00> Posted on 2025-04-12 </time></div><div class=entry><p>In the <a href=../202503191700-search-engine-part-2/>part 2</a> and <a href=../202503231000-search-engine-part-3/>part 3</a>, we implemented the way to store the indexed data and to split them in small enough pieces for the search engine to remain efficient, due to the encryption bottleneck. Now, it's time to implement read access and search functionality for our indexed entries.<h2 id=query-definition>Query Definition</h2><p>In order to execute a search, the user first needs to define its query. Considering the indexes we have, we'll have to define, for each index, a set of filters that could be executed, but we'll define them later in that article.<p>These filters can be applied to specific attributes, though this isn't always necessary. For example, we might want to search for text across all attributes, like filtering all articles having "Hello" in them, in the title or the content, with a single condition. On the other side, it's hard to imagine a use case where the user will want any article with a boolean value, whatever the attribute. That being said, this responsibility will be left to the user building the query.<p>And finally, those conditions can be combined into an expression, with <code>AND</code> or <code>OR</code>.<p>With such a structure, we could query something like <code>title:matches("search") AND author:"jeremie" AND (tags:"webassembly" OR tags:"rust") AND public:true</code>.<p>This gives us the following rust implementation, which is nothing more than a tree structure.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// Representation of a filter for each index
</span><span style=color:#c594c5>enum </span><span>Filter </span><span style=color:#5fb3b3>{
</span><span>    Boolean</span><span style=color:#5fb3b3>(...),
</span><span>    Integer</span><span style=color:#5fb3b3>(...),
</span><span>    Tag</span><span style=color:#5fb3b3>(...),
</span><span>    Text</span><span style=color:#5fb3b3>(...),
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>/// Representation of a condition on an attribute
</span><span style=color:#c594c5>struct </span><span>Condition </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// attribute it refers to
</span><span>    attribute</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    </span><span style=color:#5f6364>/// filter to apply
</span><span>    filter</span><span style=color:#5fb3b3>:</span><span> Filter,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>/// Representation of a complex expression
</span><span style=color:#c594c5>enum </span><span>Expression </span><span style=color:#5fb3b3>{
</span><span>    Condition</span><span style=color:#5fb3b3>(</span><span>Condition</span><span style=color:#5fb3b3>),
</span><span>    And</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span>Expression</span><span style=color:#5fb3b3>>, </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span>Expression</span><span style=color:#5fb3b3>>),
</span><span>    Or</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span>Expression</span><span style=color:#5fb3b3>>, </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span>Expression</span><span style=color:#5fb3b3>>),
</span><span style=color:#5fb3b3>}
</span></code></pre><p><strong>Key Points:</strong><ul><li>Flexible query language supporting complex boolean expressions<li>Typed filters for different data types<li>Optional attribute targeting for conditions<li>Composable expressions using AND/OR operators</ul><h3 id=filter-definition>Filter Definition</h3><p>The tag and boolean filters are straightforward: an entry either matches the expected term or it doesn't. This leads to the following simple filter implementations:<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>enum </span><span>BooleanFilter </span><span style=color:#5fb3b3>{
</span><span>    Equals </span><span style=color:#5fb3b3>{</span><span> value</span><span style=color:#5fb3b3>: </span><span style=color:#c594c5>bool </span><span style=color:#5fb3b3>},
</span><span style=color:#5fb3b3>}
</span><span style=color:#c594c5>enum </span><span>TagFilter </span><span style=color:#5fb3b3>{
</span><span>    Equals </span><span style=color:#5fb3b3>{</span><span> value</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>> },
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Considering the index structure defined in <a href=../202503191700-search-engine-part-2/>the part 2</a>, looking for the related entries will be fairly simple for a given attribute.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>BooleanIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>attribute</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>AttributeIndex</span><span style=color:#5fb3b3>></span><span>, </span><span style=color:#f99157>filter</span><span style=color:#5fb3b3>: &</span><span>BooleanFilter</span><span style=color:#5fb3b3>) -> </span><span>HashSet</span><span style=color:#5fb3b3><</span><span>EntryIndex</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let</span><span> postings </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>match</span><span> filter </span><span style=color:#5fb3b3>{
</span><span>            BooleanIndex</span><span style=color:#5fb3b3>::</span><span>Equals </span><span style=color:#5fb3b3>{</span><span> value </span><span style=color:#5fb3b3>} => </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>get</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>),
</span><span>        </span><span style=color:#5fb3b3>};
</span><span>        </span><span style=color:#c594c5>let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>postings</span><span style=color:#5fb3b3>) =</span><span> postings </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#5f6364>// no need to go further if the term is not found
</span><span>            </span><span style=color:#c594c5>return </span><span style=color:#fac863>Default</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#5fb3b3>};
</span><span>        </span><span style=color:#c594c5>if let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>attribute</span><span style=color:#5fb3b3>) =</span><span> attribute </span><span style=color:#5fb3b3>{
</span><span>            postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>get</span><span style=color:#5fb3b3>(&</span><span>attribute</span><span style=color:#5fb3b3>).</span><span style=color:#69c>iter</span><span style=color:#5fb3b3>().</span><span style=color:#69c>flat_map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>attr_postings</span><span style=color:#5fb3b3>| </span><span>attr_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>keys</span><span style=color:#5fb3b3>().</span><span style=color:#69c>copied</span><span style=color:#5fb3b3>())
</span><span>        </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#5f6364>// if there is not attribute specifier, we just return all the entries
</span><span>            postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter</span><span style=color:#5fb3b3>().</span><span style=color:#69c>flat_map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>attr_postings</span><span style=color:#5fb3b3>| </span><span>attr_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>keys</span><span style=color:#5fb3b3>().</span><span style=color:#69c>copied</span><span style=color:#5fb3b3>())
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>The <code>TagIndex</code> being exactly the same, we can skip its implementation.<h4 id=integer-filter>Integer Filter</h4><p>The integer filter can be a bit more complicated. We want to allow the user to be able to query a date range for example. So we'll need to implement <code>GreaterThan</code> and <code>LowerThan</code> on top of the previously defined filter.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>enum </span><span>IntegerFilter </span><span style=color:#5fb3b3>{
</span><span>    Equals </span><span style=color:#5fb3b3>{</span><span> value</span><span style=color:#5fb3b3>: </span><span style=color:#c594c5>u64 </span><span style=color:#5fb3b3>},
</span><span>    GreaterThan </span><span style=color:#5fb3b3>{</span><span> value</span><span style=color:#5fb3b3>: </span><span style=color:#c594c5>u64 </span><span style=color:#5fb3b3>},
</span><span>    LowerThan </span><span style=color:#5fb3b3>{</span><span> value</span><span style=color:#5fb3b3>: </span><span style=color:#c594c5>u64 </span><span style=color:#5fb3b3>},
</span><span style=color:#5fb3b3>}
</span></code></pre><p>But the <code>IntegerIndex</code> indexes the possible values with a <code>BTreeMap</code>, which allows us to query the values by range. And with all the possible attributes and entries, we can fetch the different entries.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>IntegerIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>filter_content</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>filter</span><span style=color:#5fb3b3>: &</span><span>IntegerFilter</span><span style=color:#5fb3b3>) -></span><span> impl </span><span style=color:#fac863>Iterator</span><span style=color:#5fb3b3><</span><span>Item = </span><span style=color:#5fb3b3>&</span><span>HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, HashSet</span><span style=color:#5fb3b3><</span><span>ValueIndex</span><span style=color:#5fb3b3>>>>> {
</span><span>        </span><span style=color:#c594c5>match</span><span> filter </span><span style=color:#5fb3b3>{
</span><span>            IntegerFilter</span><span style=color:#5fb3b3>::</span><span>Equals </span><span style=color:#5fb3b3>{</span><span> value </span><span style=color:#5fb3b3>} => </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>range</span><span style=color:#5fb3b3>(*</span><span>value</span><span style=color:#5fb3b3>..=*</span><span>value</span><span style=color:#5fb3b3>),
</span><span>            IntegerFilter</span><span style=color:#5fb3b3>::</span><span>GreaterThan </span><span style=color:#5fb3b3>{</span><span> value </span><span style=color:#5fb3b3>} => </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>range</span><span style=color:#5fb3b3>((*</span><span>value </span><span style=color:#5fb3b3>+ </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>)..),
</span><span>            IntegerFilter</span><span style=color:#5fb3b3>::</span><span>LowerThan </span><span style=color:#5fb3b3>{</span><span> value </span><span style=color:#5fb3b3>} => </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>range</span><span style=color:#5fb3b3>(..*</span><span>value</span><span style=color:#5fb3b3>),
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>attribute</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>AttributeIndex</span><span style=color:#5fb3b3>></span><span>, </span><span style=color:#f99157>filter</span><span style=color:#5fb3b3>: &</span><span>IntegerFilter</span><span style=color:#5fb3b3>) -> </span><span>HashSet</span><span style=color:#5fb3b3><</span><span>EntryIndex</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>if let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>attribute</span><span style=color:#5fb3b3>) =</span><span> attribute </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>filter_content</span><span style=color:#5fb3b3>(</span><span>filter</span><span style=color:#5fb3b3>)
</span><span>                </span><span style=color:#5f6364>// here we filter for the given attribute
</span><span>                </span><span style=color:#5fb3b3>.</span><span style=color:#69c>flat_map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>postings</span><span style=color:#5fb3b3>| </span><span>postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>get</span><span style=color:#5fb3b3>(&</span><span>attribute</span><span style=color:#5fb3b3>).</span><span style=color:#69c>iter</span><span style=color:#5fb3b3>())
</span><span>                </span><span style=color:#5fb3b3>.</span><span style=color:#69c>flat_map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>entries</span><span style=color:#5fb3b3>| </span><span>entries</span><span style=color:#5fb3b3>.</span><span style=color:#69c>keys</span><span style=color:#5fb3b3>().</span><span style=color:#69c>copied</span><span style=color:#5fb3b3>())
</span><span>                </span><span style=color:#5fb3b3>.</span><span style=color:#69c>collect</span><span style=color:#5fb3b3>()
</span><span>        </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>filter_content</span><span style=color:#5fb3b3>(</span><span>filter</span><span style=color:#5fb3b3>)
</span><span>                </span><span style=color:#5f6364>// here we take all the attributes
</span><span>                </span><span style=color:#5fb3b3>.</span><span style=color:#69c>flat_map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>postings</span><span style=color:#5fb3b3>| </span><span>postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>values</span><span style=color:#5fb3b3>())
</span><span>                </span><span style=color:#5fb3b3>.</span><span style=color:#69c>flat_map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>entries</span><span style=color:#5fb3b3>| </span><span>entries</span><span style=color:#5fb3b3>.</span><span style=color:#69c>keys</span><span style=color:#5fb3b3>().</span><span style=color:#69c>copied</span><span style=color:#5fb3b3>())
</span><span>                </span><span style=color:#5fb3b3>.</span><span style=color:#69c>collect</span><span style=color:#5fb3b3>()
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Once again, we end up having a faily simple implementation.<p><strong>Filter Implementation Achievements:</strong><ul><li>Boolean filters for simple true/false matching<li>Integer filters supporting range queries<li>Tag filters for exact string matching<li>Memory-efficient implementation using numeric indexes</ul><h4 id=text-filter>Text Filter</h4><p>Now let's tackle the most complex piece. Searching through text is only easy when looking for exact values. We need something more clever here.<p>We want to support fuzzy matching, where searching for "Moovies" would match "movie" and this is done by implementing some <a href=https://en.wikipedia.org/wiki/Approximate_string_matching rel=noopener target=_blank>fuzzy search</a>.<p>We also want something that allows to find words starting with a value (searching <code>title:starts_with("Artic")</code> should catch "Article"). This is a subset of the <a href=https://en.wikipedia.org/wiki/Wildcard_character rel=noopener target=_blank>wildcard search</a>.<p>This gives us the following filter<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>enum </span><span>TextFilter </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>// searching for the exact value
</span><span>    Equals </span><span style=color:#5fb3b3>{</span><span> value</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>> },
</span><span>    </span><span style=color:#5f6364>// matching the prefix
</span><span>    StartsWith </span><span style=color:#5fb3b3>{</span><span> prefix</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>> },
</span><span>    </span><span style=color:#5f6364>// fuzzy search
</span><span>    Matches </span><span style=color:#5fb3b3>{</span><span> value</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>> },
</span><span style=color:#5fb3b3>}
</span></code></pre><p>The <code>Equals</code> implementation is similar to the previous indexes so we'll skip it.<h5 id=prefix-search>Prefix Search</h5><p>In order to implement the <code>StartsWith</code> filter without going through the entire content of the index, we need to precompute a structure. This structure will be a simple tree where each node is a character.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5fb3b3>#[</span><span>derive</span><span style=color:#5fb3b3>(</span><span>Debug</span><span style=color:#5fb3b3>,</span><span> Default</span><span style=color:#5fb3b3>)]
</span><span style=color:#c594c5>pub</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>super</span><span style=color:#5fb3b3>) </span><span style=color:#c594c5>struct </span><span>TrieNode </span><span style=color:#5fb3b3>{
</span><span>    children</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>char</span><span>, TrieNode</span><span style=color:#5fb3b3>></span><span>,
</span><span>    term</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>That way, finding the words matching a prefix will just need to go through each letters of that prefix in the tree, and all children are the potential words.<p>Finding the final node for the <code>StartsWith</code> filter is done as following<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>TrieNode </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>find_starts_with</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#c594c5>mut </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>: </span><span>Chars</span><span style=color:#5fb3b3><</span><span>'</span><span style=color:#5fb3b3>_>) -> </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><&</span><span>TrieNode</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let</span><span> character </span><span style=color:#5fb3b3>=</span><span> value</span><span style=color:#5fb3b3>.</span><span style=color:#69c>next</span><span style=color:#5fb3b3>()?;
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>children
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>get</span><span style=color:#5fb3b3>(&</span><span>character</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>and_then</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>child</span><span style=color:#5fb3b3>| </span><span>child</span><span style=color:#5fb3b3>.</span><span style=color:#69c>find_starts_with</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>))
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>And once we get the node, we need to iterate through the entire tree structure of the children to collect the matching words. This can be done by implementing an iterator.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5fb3b3>#[</span><span>derive</span><span style=color:#5fb3b3>(</span><span>Debug</span><span style=color:#5fb3b3>,</span><span> Default</span><span style=color:#5fb3b3>)]
</span><span style=color:#c594c5>struct </span><span>TrieNodeTermIterator</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'n</span><span style=color:#5fb3b3>> {
</span><span>    queue</span><span style=color:#5fb3b3>: </span><span>VecDeque</span><span style=color:#5fb3b3><&</span><span style=color:#c594c5>'n</span><span> TrieNode</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'t</span><span style=color:#5fb3b3>> </span><span>TrieNodeTermIterator</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'t</span><span style=color:#5fb3b3>> {
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>new</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>node</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>'t</span><span> TrieNode</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>Self </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>Self </span><span style=color:#5fb3b3>{
</span><span>            queue</span><span style=color:#5fb3b3>: </span><span>VecDeque</span><span style=color:#5fb3b3>::</span><span>from_iter</span><span style=color:#5fb3b3>([</span><span>node</span><span style=color:#5fb3b3>]),
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>Iterator </span><span style=color:#c594c5>for </span><span>TrieNodeTermIterator</span><span style=color:#5fb3b3><</span><span>'</span><span style=color:#5fb3b3>_> {
</span><span>    </span><span style=color:#c594c5>type </span><span>Item </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>;
</span><span>
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>next</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>Self</span><span style=color:#5fb3b3>::</span><span>Item</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let</span><span> next </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>queue</span><span style=color:#5fb3b3>.</span><span style=color:#69c>pop_front</span><span style=color:#5fb3b3>()?;
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>queue</span><span style=color:#5fb3b3>.</span><span style=color:#69c>extend</span><span style=color:#5fb3b3>(</span><span>next</span><span style=color:#5fb3b3>.</span><span>children</span><span style=color:#5fb3b3>.</span><span style=color:#69c>values</span><span style=color:#5fb3b3>());
</span><span>        </span><span style=color:#c594c5>if let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>) =</span><span> next</span><span style=color:#5fb3b3>.</span><span>term </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>())
</span><span>        </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>next</span><span style=color:#5fb3b3>()
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>TrieNode </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>prefix</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>) -></span><span> impl </span><span style=color:#fac863>Iterator</span><span style=color:#5fb3b3><</span><span>Item = </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#c594c5>if let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>found</span><span style=color:#5fb3b3>) = </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>find_starts_with</span><span style=color:#5fb3b3>(</span><span>prefix</span><span style=color:#5fb3b3>.</span><span style=color:#69c>chars</span><span style=color:#5fb3b3>()) {
</span><span>            TrieNodeTermIterator</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>(</span><span>found</span><span style=color:#5fb3b3>)
</span><span>        </span><span style=color:#5fb3b3>} </span><span style=color:#c594c5>else </span><span style=color:#5fb3b3>{
</span><span>            TrieNodeTermIterator</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>()
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Once we have those words, we can simply deduce matching the entries.<h5 id=fuzzy-search>Fuzzy Search</h5><p>Fuzzy searching is done by extracting, for each words, all the possible subsets of <code>N</code> letters and creating an index from that. Then, when queried, we take the value to match against, extract all the possible subsets of <code>N</code> words, and the words <em>matching the most</em>, should be kept.<p>In our case, we'll use <code>N=3</code>, because it's what's used in Postgres to improve the fuzzy search performance and it's suggested in <a href=https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380180407 rel=noopener target=_blank>some research papers</a>.<p>Building that trigram index will come at a cost: we'll have to process the entire index. But this should be relatively fast considering this is a simple process. Building the trigrams can be done using the <a href=https://crates.io/crates/substr-iterator rel=noopener target=_blank><code>substr-iterator</code> crate</a>.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5fb3b3>#[</span><span>derive</span><span style=color:#5fb3b3>(</span><span>Default</span><span style=color:#5fb3b3>)]
</span><span style=color:#c594c5>struct </span><span>Trigrams</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'a</span><span style=color:#5fb3b3>>(</span><span>HashMap</span><span style=color:#5fb3b3><[</span><span style=color:#c594c5>char</span><span style=color:#5fb3b3>; </span><span style=color:#f99157>3</span><span style=color:#5fb3b3>]</span><span>, HashSet</span><span style=color:#5fb3b3><&</span><span style=color:#c594c5>'a str</span><span style=color:#5fb3b3>>>);
</span><span>
</span><span style=color:#c594c5>impl</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'a</span><span style=color:#5fb3b3>> </span><span>Trigrams</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'a</span><span style=color:#5fb3b3>> {
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>) {
</span><span>        TrigramIter</span><span style=color:#5fb3b3>::</span><span>from</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>).</span><span style=color:#69c>for_each</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>trigram</span><span style=color:#5fb3b3>| {
</span><span>            </span><span style=color:#c594c5>let</span><span> set</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>mut </span><span>HashSet</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>usize</span><span style=color:#5fb3b3>> = </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#f99157>0.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>trigram</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>            set</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>});
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>TextIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>trigrams</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>Trigrams</span><span style=color:#5fb3b3><</span><span>'</span><span style=color:#5fb3b3>_> {
</span><span>        </span><span style=color:#c594c5>let mut</span><span> res </span><span style=color:#5fb3b3>= </span><span>Trigrams</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>keys</span><span style=color:#5fb3b3>().</span><span style=color:#69c>for_each</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>word</span><span style=color:#5fb3b3>| {
</span><span>            res</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>word</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>});
</span><span>        res
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Once this is done, we can search all the possible terms with the following function<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'a</span><span style=color:#5fb3b3>> </span><span>Trigrams</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>'a</span><span style=color:#5fb3b3>> {
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>term</span><span style=color:#5fb3b3>: &</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>) -></span><span> impl </span><span style=color:#fac863>Iterator</span><span style=color:#5fb3b3><</span><span>Item = </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>> {
</span><span>        TrigramIter</span><span style=color:#5fb3b3>::</span><span>from</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>filter_map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>tri</span><span style=color:#5fb3b3>| </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#f99157>0.</span><span style=color:#69c>get</span><span style=color:#5fb3b3>(&</span><span>tri</span><span style=color:#5fb3b3>))
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>flatten</span><span style=color:#5fb3b3>()
</span><span>            </span><span style=color:#5f6364>// this is provided by the itertools crate
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>unique</span><span style=color:#5fb3b3>()
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3>::</span><span>from</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><h5 id=scoring-the-matching-entries>Scoring The Matching entries</h5><p>Now that we have all the possible terms matching the filter, we need to provide some kind of score. But first, should we accept all the matching terms? Should querying <code>macro</code> match <code>pneumonoultramicroscopicsilicovolcanoconiosis</code>?<p>Doing such a filtering can be done computing the <a href=https://en.wikipedia.org/wiki/Levenshtein_distance rel=noopener target=_blank>Levenshtein distance</a> of the queried word with the word we found and only keep the word having a distance smaller than half of the length of the queried word. No need to reinvent the wheel here, the <a href=https://crates.io/crates/distance rel=noopener target=_blank><code>distance</code> crate</a> implements it.<p>Next, we'll compute scores for each term using the <a href=https://en.wikipedia.org/wiki/Okapi_BM25 rel=noopener target=_blank>Okapi BM25 algorithm</a>. For this, we'll need several metrics including the collection size (number of entries in the shard), the size of the entry (number of tokens for the requested attribute) and the average length of the attribute accross all the collection.<p>In order to avoid recomputing this for each search, we'll update the <code>TextIndex</code> to persist these values each time we update the text index.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>pub struct </span><span>TextIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// content of the text index
</span><span>    content</span><span style=color:#5fb3b3>:</span><span> ...,
</span><span>    </span><span style=color:#5f6364>/// number of tokens per attribute
</span><span>    attributes</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, </span><span style=color:#c594c5>u32</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5f6364>/// number of tokens per entry per attribute
</span><span>    entries</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, HashMap</span><span style=color:#5fb3b3><</span><span>AttributeIndex, </span><span style=color:#c594c5>u32</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>With these values persisted, querying the search engine can be done this way.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>// FYI this piece of code is not supposed to compile, nor to be efficient
</span><span>
</span><span style=color:#c594c5>impl </span><span>TextIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// computes the score for each entry based on the found terms
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>compute_scores</span><span style=color:#5fb3b3>(
</span><span>        </span><span style=color:#5fb3b3>&</span><span style=color:#f99157>self</span><span>,
</span><span>        </span><span style=color:#f99157>attribute</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>AttributeIndex</span><span style=color:#5fb3b3>></span><span>,
</span><span>        </span><span style=color:#f99157>matchings</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, HashMap</span><span style=color:#5fb3b3><&</span><span style=color:#c594c5>str</span><span>, </span><span style=color:#c594c5>usize</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    </span><span style=color:#5fb3b3>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let</span><span> collection_size </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>collection_size</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> avg_length </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>collection_avg_length</span><span style=color:#5fb3b3>(</span><span>attribute</span><span style=color:#5fb3b3>);
</span><span>        matching
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>into_iter</span><span style=color:#5fb3b3>()
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(|(</span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>terms</span><span style=color:#5fb3b3>)| {
</span><span>                </span><span style=color:#c594c5>let</span><span> entry_length </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry_length</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>,</span><span> attribute</span><span style=color:#5fb3b3>);
</span><span>                </span><span style=color:#c594c5>let mut</span><span> score </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0.0</span><span style=color:#5fb3b3>;
</span><span>                </span><span style=color:#c594c5>for </span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>,</span><span> freq_in_entry</span><span style=color:#5fb3b3>) in</span><span> terms </span><span style=color:#5fb3b3>{
</span><span>                    </span><span style=color:#c594c5>let</span><span> entries_with_term </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>count_entries_with_term</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>,</span><span> attribute</span><span style=color:#5fb3b3>);
</span><span>                    </span><span style=color:#5f6364>// have a look at the wikipedia page for the formula, it will be simpler to read
</span><span>                    </span><span style=color:#c594c5>let</span><span> idf </span><span style=color:#5fb3b3>= </span><span style=color:#69c>compute_idf</span><span style=color:#5fb3b3>(</span><span>collection_size</span><span style=color:#5fb3b3>,</span><span> entries_with_term</span><span style=color:#5fb3b3>);
</span><span>                    score </span><span style=color:#5fb3b3>+= </span><span style=color:#69c>compute_bm25_score</span><span style=color:#5fb3b3>(</span><span>idf</span><span style=color:#5fb3b3>,</span><span> freq_in_entry</span><span style=color:#5fb3b3>,</span><span> entry_length</span><span style=color:#5fb3b3>,</span><span> avg_length</span><span style=color:#5fb3b3>);
</span><span>                </span><span style=color:#5fb3b3>}
</span><span>                </span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>,</span><span> score</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>})
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>collec</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#5f6364>/// reduce the list of terms and return the entries matching the terms
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>reduce_matches</span><span style=color:#5fb3b3>(
</span><span>        </span><span style=color:#5fb3b3>&</span><span style=color:#f99157>self</span><span>,
</span><span>        </span><span style=color:#f99157>attribute</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>AttributeIndex</span><span style=color:#5fb3b3>></span><span>,
</span><span>        </span><span style=color:#f99157>terms</span><span style=color:#5fb3b3>:</span><span> impl </span><span style=color:#fac863>Iterator</span><span style=color:#5fb3b3><</span><span>Item = </span><span style=color:#5fb3b3>&</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5fb3b3>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, HashMap</span><span style=color:#5fb3b3><&</span><span style=color:#c594c5>str</span><span>, </span><span style=color:#c594c5>usize</span><span style=color:#5fb3b3>>> {
</span><span>        </span><span style=color:#c594c5>let mut</span><span> res </span><span style=color:#5fb3b3>= </span><span>HashMap</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>for</span><span> term </span><span style=color:#5fb3b3>in</span><span> terms </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>for</span><span> entry_index </span><span style=color:#5fb3b3>in </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>find_entries_for_term</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>) {
</span><span>                </span><span style=color:#c594c5>let</span><span> entry </span><span style=color:#5fb3b3>=</span><span> res</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>                </span><span style=color:#5f6364>// count the occurences of that term in the entry
</span><span>                entry</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>).</span><span style=color:#69c>and_modify</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>v</span><span style=color:#5fb3b3>| {
</span><span>                    </span><span style=color:#5fb3b3>*</span><span>v </span><span style=color:#5fb3b3>+= </span><span style=color:#f99157>1</span><span style=color:#5fb3b3>;
</span><span>                </span><span style=color:#5fb3b3>}).</span><span style=color:#69c>or_insert</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>1</span><span style=color:#5fb3b3>);
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>        res
</span><span>    </span><span style=color:#5fb3b3>}
</span><span>
</span><span>    </span><span style=color:#5f6364>/// search through the index
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3>(
</span><span>        </span><span style=color:#5fb3b3>&</span><span style=color:#f99157>self</span><span>,
</span><span>        </span><span style=color:#f99157>attribute</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>AttributeIndex</span><span style=color:#5fb3b3>></span><span>,
</span><span>        </span><span style=color:#f99157>filter</span><span style=color:#5fb3b3>: &</span><span>TextFilter,
</span><span>    </span><span style=color:#5fb3b3>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let</span><span> matching_terms </span><span style=color:#5fb3b3>= </span><span style=color:#c594c5>match</span><span> filter </span><span style=color:#5fb3b3>{
</span><span>            TextFilter</span><span style=color:#5fb3b3>::</span><span>StartsWith </span><span style=color:#5fb3b3>{</span><span> prefix </span><span style=color:#5fb3b3>} => </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>trienodes</span><span style=color:#5fb3b3>().</span><span style=color:#69c>search</span><span style=color:#5fb3b3>(</span><span>prefix</span><span style=color:#5fb3b3>),
</span><span>            TextFilter</span><span style=color:#5fb3b3>::</span><span>Matches </span><span style=color:#5fb3b3>{</span><span> value </span><span style=color:#5fb3b3>} => </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>trigrams</span><span style=color:#5fb3b3>().</span><span style=color:#69c>search</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>),
</span><span>            TextFilter</span><span style=color:#5fb3b3>::</span><span>Equals </span><span style=color:#5fb3b3>{</span><span> value </span><span style=color:#5fb3b3>} => </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>inner</span><span style=color:#5fb3b3>.</span><span style=color:#69c>get_term</span><span style=color:#5fb3b3>(</span><span>value</span><span style=color:#5fb3b3>).</span><span style=color:#69c>into_iter</span><span style=color:#5fb3b3>(),
</span><span>        </span><span style=color:#5fb3b3>};
</span><span>        </span><span style=color:#c594c5>let</span><span> matching_entries </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>reduce_matches</span><span style=color:#5fb3b3>(</span><span>attribute</span><span style=color:#5fb3b3>,</span><span> matching_terms</span><span style=color:#5fb3b3>)
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>compute_scores</span><span style=color:#5fb3b3>(</span><span>attribute</span><span style=color:#5fb3b3>,</span><span> matchings</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>With that code, we end up with a map of all the matching entries with a score.<p><strong>Text Search Achievements:</strong><ul><li>Prefix search using trie data structure<li>Fuzzy search using trigram indexing<li>Levenshtein distance filtering for result relevance<li>BM25 scoring for accurate result ranking<li>Efficient caching of collection statistics</ul><h2 id=query-execution>Query Execution</h2><p>Now that we have a way to build the expression of the query, we can query individualy each index, it's time to plug everything together in order to execute a complete search.<p>As a reminder, considering the engine is organised in shards, the search will simply being executing the search on every shard. But considering the search might take some time, the search should return the results as each shard is processed.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>SearchEngine </span><span style=color:#5fb3b3>{
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3><</span><span>Cb</span><span style=color:#5fb3b3>>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>expression</span><span style=color:#5fb3b3>: &</span><span>Expression, </span><span style=color:#f99157>callback</span><span style=color:#5fb3b3>:</span><span> Cb</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>usize</span><span style=color:#5fb3b3>>
</span><span>    </span><span style=color:#c594c5>where
</span><span>        Cb</span><span style=color:#5fb3b3>:</span><span> Fn</span><span style=color:#5fb3b3>(</span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>>)
</span><span>    </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>let mut</span><span> found </span><span style=color:#5fb3b3>= </span><span style=color:#f99157>0</span><span style=color:#5fb3b3>;
</span><span>        </span><span style=color:#c594c5>for </span><span style=color:#5fb3b3>(</span><span>_shard_key</span><span style=color:#5fb3b3>,</span><span> shard</span><span style=color:#5fb3b3>) in </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>shards </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>let</span><span> result </span><span style=color:#5fb3b3>=</span><span> shard</span><span style=color:#5fb3b3>.</span><span style=color:#69c>search</span><span style=color:#5fb3b3>(</span><span>expression</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>            found </span><span style=color:#5fb3b3>+=</span><span> result</span><span style=color:#5fb3b3>.</span><span style=color:#69c>len</span><span style=color:#5fb3b3>();
</span><span>            </span><span style=color:#69c>callback</span><span style=color:#5fb3b3>(</span><span>result</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span>found</span><span style=color:#5fb3b3>)
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>After defining the high level, we can go one level down, and look at how it works at the shard level.<h3 id=caching-file-content>Caching File Content</h3><p>A shard is only defined by the names of the files it's composed of.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>struct </span><span>ShardManifest </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// the collection is mandatory, it's the index of all the entries
</span><span>    </span><span style=color:#5f6364>/// if it's none, there's no entry, so there's no shard
</span><span>    collection</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5f6364>/// then every index is optional (except the integer index, but we'll keep the same idea)
</span><span>    boolean</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    integer</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    tag</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    text</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span style=color:#fac863>Box</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Which means that, for each condition in the search expression, we'll need to load the collection to find the <code>AttributeIndex</code> for the given attribute name, and then load the corresponding index and execute the query. We could load all of the indexes when starting a search in the shard but we might not need all of them and considering the decryption cost, we should avoid that.<p>Let's add an abstraction layer for the shard.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>struct </span><span>Shard </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// this is loaded anyway
</span><span>    collection</span><span style=color:#5fb3b3>:</span><span> Collection,
</span><span>    </span><span style=color:#5f6364>/// then we create a cache
</span><span>    boolean</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>CachedEncryptedFile</span><span style=color:#5fb3b3><</span><span>BooleanIndex</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    integer</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>CachedEncryptedFile</span><span style=color:#5fb3b3><</span><span>IntegerIndex</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    tag</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>CachedEncryptedFile</span><span style=color:#5fb3b3><</span><span>TagIndex</span><span style=color:#5fb3b3>>></span><span>,
</span><span>    text</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>CachedEncryptedFile</span><span style=color:#5fb3b3><</span><span>TextIndex</span><span style=color:#5fb3b3>>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>struct </span><span>CachedEncryptedFile</span><span style=color:#5fb3b3><</span><span>T</span><span style=color:#5fb3b3>> {
</span><span>    file</span><span style=color:#5fb3b3>:</span><span> EncryptedFile,
</span><span>    cache</span><span style=color:#5fb3b3>: </span><span>async_lock</span><span style=color:#5fb3b3>::</span><span>OnceCell</span><span style=color:#5fb3b3><</span><span>T</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl</span><span style=color:#5fb3b3><</span><span>T</span><span style=color:#5fb3b3>: </span><span>serde</span><span style=color:#5fb3b3>::</span><span>de</span><span style=color:#5fb3b3>::</span><span>DeserializedOwned</span><span style=color:#5fb3b3>> </span><span>CachedEncryptedFile</span><span style=color:#5fb3b3><</span><span>T</span><span style=color:#5fb3b3>> {
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>get</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span>std</span><span style=color:#5fb3b3>::</span><span>io</span><span style=color:#5fb3b3>::</span><span style=color:#fac863>Result</span><span style=color:#5fb3b3><&</span><span>T</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>cache
</span><span>            </span><span style=color:#5f6364>// here we only deserialize the file when we need to access it
</span><span>            </span><span style=color:#5f6364>// and it remains cached
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>get_or_try_init</span><span style=color:#5fb3b3>(|| </span><span>async </span><span style=color:#5fb3b3>{ </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>file</span><span style=color:#5fb3b3>.</span><span>deserialize</span><span style=color:#5fb3b3>::<</span><span>T</span><span style=color:#5fb3b3>>().</span><span>await </span><span style=color:#5fb3b3>})
</span><span>            </span><span style=color:#5fb3b3>.</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>With that level of abstraction, we're sure the files are only loaded once in memory.<h3 id=calling-async-code-in-every-condition>Calling Async Code In Every Condition</h3><p>Now it's time to face the next problem: executing the query. From a first point of view, it should be fairly simple, the expression is a dumb tree where the leaves are conditions. So, to run this, we could just recursively call the indexes in the conditions and reduce at the expression level.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>Shard </span><span style=color:#5fb3b3>{
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>search</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>expression</span><span style=color:#5fb3b3>: &</span><span>Expression</span><span style=color:#5fb3b3>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>> {
</span><span>        expression</span><span style=color:#5fb3b3>.</span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(</span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>).</span><span>await
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>impl </span><span>Expression </span><span style=color:#5fb3b3>{
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>shard</span><span style=color:#5fb3b3>: &</span><span>Shard</span><span style=color:#5fb3b3>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>match </span><span style=color:#ec5f67>self </span><span style=color:#5fb3b3>{
</span><span>            Expression</span><span style=color:#5fb3b3>::</span><span>Condition</span><span style=color:#5fb3b3>(</span><span>condition</span><span style=color:#5fb3b3>) =></span><span> condition</span><span style=color:#5fb3b3>.</span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(</span><span>shard</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>,
</span><span>            Expression</span><span style=color:#5fb3b3>::</span><span>And</span><span style=color:#5fb3b3>(</span><span>left</span><span style=color:#5fb3b3>,</span><span> right</span><span style=color:#5fb3b3>) => {
</span><span>                </span><span style=color:#c594c5>let</span><span> left_res </span><span style=color:#5fb3b3>=</span><span> left</span><span style=color:#5fb3b3>.</span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(</span><span>shard</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>                </span><span style=color:#c594c5>let</span><span> right_res </span><span style=color:#5fb3b3>=</span><span> right</span><span style=color:#5fb3b3>.</span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(</span><span>shard</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>                </span><span style=color:#69c>reduce_and</span><span style=color:#5fb3b3>(</span><span>left_res</span><span style=color:#5fb3b3>,</span><span> right_res</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>},
</span><span>            Expression</span><span style=color:#5fb3b3>::</span><span>Or</span><span style=color:#5fb3b3>(</span><span>left</span><span style=color:#5fb3b3>,</span><span> right</span><span style=color:#5fb3b3>) => {
</span><span>                </span><span style=color:#c594c5>let</span><span> left_res </span><span style=color:#5fb3b3>=</span><span> left</span><span style=color:#5fb3b3>.</span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(</span><span>shard</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>                </span><span style=color:#c594c5>let</span><span> right_res </span><span style=color:#5fb3b3>=</span><span> right</span><span style=color:#5fb3b3>.</span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(</span><span>shard</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>                </span><span style=color:#69c>reduce_or</span><span style=color:#5fb3b3>(</span><span>left_res</span><span style=color:#5fb3b3>,</span><span> right_res</span><span style=color:#5fb3b3>)
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>However, this approach won't work well because recursive async calls are problematic. So we should convert this to a sequential process.<p>To make this sequential, the trick is to create an iterator in the <code>Expression</code> tree. That way, the following expression tree should be serialized as follow<pre style=color:#cccece;background-color:#2b2c2f><code><span>             author:"alice"
</span><span>           /
</span><span>        OR
</span><span>      /    \
</span><span>     /       author:"bob"
</span><span>    /
</span><span>AND
</span><span>    \
</span><span>     \
</span><span>      \
</span><span>        title:"Hello"
</span><span>e
</span><span>[cond(author:"alice"), cond(author:"bob"), OR, cond(title:"Hello"), AND]
</span></code></pre><p>So that we can use a <a href=https://en.wikipedia.org/wiki/Reverse_Polish_notation rel=noopener target=_blank>Reverse Polish Notation</a> to compute the scores.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>Expression </span><span style=color:#5fb3b3>{
</span><span>    async </span><span style=color:#c594c5>fn </span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>shard</span><span style=color:#5fb3b3>: &</span><span>Shard</span><span style=color:#5fb3b3>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#c594c5>let mut</span><span> stack </span><span style=color:#5fb3b3>= </span><span style=color:#fac863>Vec</span><span style=color:#5fb3b3>::</span><span>new</span><span style=color:#5fb3b3>();
</span><span>
</span><span>        </span><span style=color:#c594c5>for</span><span> item </span><span style=color:#5fb3b3>in </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter</span><span style=color:#5fb3b3>() {
</span><span>            </span><span style=color:#c594c5>match</span><span> item </span><span style=color:#5fb3b3>{
</span><span>                Item</span><span style=color:#5fb3b3>::</span><span>Condition</span><span style=color:#5fb3b3>(</span><span>cond</span><span style=color:#5fb3b3>) => {
</span><span>                    </span><span style=color:#c594c5>let</span><span> result </span><span style=color:#5fb3b3>=</span><span> condition</span><span style=color:#5fb3b3>.</span><span style=color:#69c>execute</span><span style=color:#5fb3b3>(</span><span>shard</span><span style=color:#5fb3b3>).</span><span>await</span><span style=color:#5fb3b3>?;
</span><span>                    stack</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span style=color:#5fb3b3>(</span><span>result</span><span style=color:#5fb3b3>);
</span><span>                </span><span style=color:#5fb3b3>}
</span><span>                </span><span style=color:#5f6364>// kind is AND/OR
</span><span>                Item</span><span style=color:#5fb3b3>::</span><span>Expression</span><span style=color:#5fb3b3>(</span><span>kind</span><span style=color:#5fb3b3>) => {
</span><span>                    </span><span style=color:#c594c5>let</span><span> right </span><span style=color:#5fb3b3>=</span><span> stack</span><span style=color:#5fb3b3>.</span><span style=color:#69c>pop</span><span style=color:#5fb3b3>().</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>();
</span><span>                    </span><span style=color:#c594c5>let</span><span> left </span><span style=color:#5fb3b3>=</span><span> stack</span><span style=color:#5fb3b3>.</span><span style=color:#69c>pop</span><span style=color:#5fb3b3>().</span><span style=color:#69c>unwrap</span><span style=color:#5fb3b3>();
</span><span>                    stack</span><span style=color:#5fb3b3>.</span><span style=color:#69c>push</span><span style=color:#5fb3b3>(</span><span style=color:#69c>aggregate</span><span style=color:#5fb3b3>(</span><span>kind</span><span style=color:#5fb3b3>,</span><span> left</span><span style=color:#5fb3b3>,</span><span> right</span><span style=color:#5fb3b3>));
</span><span>                </span><span style=color:#5fb3b3>}
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>
</span><span>        </span><span style=color:#fac863>Ok</span><span style=color:#5fb3b3>(</span><span>stack</span><span style=color:#5fb3b3>.</span><span style=color:#69c>pop</span><span style=color:#5fb3b3>().</span><span style=color:#69c>unwrap_or_default</span><span style=color:#5fb3b3>())
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>Which fixes the problem of not being able to execute async calls.<blockquote><p>We could have used a crate like <a href=https://crates.io/crates/async-recursion rel=noopener target=_blank><code>async-recursion</code></a> to handle this but I find this solution more elegant.</blockquote><h3 id=joining-the-results>Joining The results</h3><p>We have some inconsistencies in our search implementations. The <code>TextIndex</code> returns a <code>HashMap&LTEntryIndex, f64></code> while the others return a <code>HashSet&LTEntryIndex></code>. This is due to the lack of score in the other indexes. In order to be able to search with only those indexes (boolean, integer or tag), we need to implement that scoring mechanism as well.<blockquote><p>The logic is fairly straightforward and similar to what was done in the text index, so I'll leave it up to you here.</blockquote><p>Now we need to implement the <code>aggregate</code> function we used in the piece of code above. We will try to normalise the scores in <code>0..1</code> to make them equally important and to prevent a score inflation.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>fn </span><span style=color:#69c>normalise</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>mut </span><span style=color:#f99157>scores</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>> {
</span><span>    </span><span style=color:#c594c5>let</span><span> max </span><span style=color:#5fb3b3>=</span><span> scores</span><span style=color:#5fb3b3>.</span><span style=color:#69c>values</span><span style=color:#5fb3b3>().</span><span style=color:#69c>copied</span><span style=color:#5fb3b3>().</span><span style=color:#69c>fold</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>0.0</span><span style=color:#5fb3b3>, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>::</span><span>max</span><span style=color:#5fb3b3>);
</span><span>    scores</span><span style=color:#5fb3b3>.</span><span style=color:#69c>values_mut</span><span style=color:#5fb3b3>().</span><span style=color:#69c>for_each</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>value</span><span style=color:#5fb3b3>| {
</span><span>        </span><span style=color:#5fb3b3>*</span><span>value </span><span style=color:#5fb3b3>/=</span><span> max</span><span style=color:#5fb3b3>;
</span><span>    </span><span style=color:#5fb3b3>});
</span><span>    scores
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>fn </span><span style=color:#69c>aggregate</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>kind</span><span style=color:#5fb3b3>:</span><span> Kind, </span><span style=color:#c594c5>mut </span><span style=color:#f99157>left</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>></span><span>, </span><span style=color:#c594c5>mut </span><span style=color:#f99157>right</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>>) -> </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>EntryIndex, </span><span style=color:#c594c5>f64</span><span style=color:#5fb3b3>> {
</span><span>    </span><span style=color:#c594c5>let</span><span> left </span><span style=color:#5fb3b3>= </span><span style=color:#69c>normalise</span><span style=color:#5fb3b3>(</span><span>left</span><span style=color:#5fb3b3>);
</span><span>    </span><span style=color:#c594c5>let</span><span> right </span><span style=color:#5fb3b3>= </span><span style=color:#69c>normalise</span><span style=color:#5fb3b3>(</span><span>right</span><span style=color:#5fb3b3>);
</span><span>    </span><span style=color:#c594c5>match</span><span> kind </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#5f6364>// we want the intersection
</span><span>        Kind</span><span style=color:#5fb3b3>::</span><span>And </span><span style=color:#5fb3b3>=></span><span> left</span><span style=color:#5fb3b3>.</span><span style=color:#69c>into_iter</span><span style=color:#5fb3b3>()
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>filter_map</span><span style=color:#5fb3b3>(|(</span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>score_left</span><span style=color:#5fb3b3>)| {
</span><span>                right
</span><span>                    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&</span><span>entry_index</span><span style=color:#5fb3b3>)
</span><span>                    </span><span style=color:#5f6364>// we use a multiplication to join scores
</span><span>                    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>map</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>score_right</span><span style=color:#5fb3b3>| (</span><span>entry_index</span><span style=color:#5fb3b3>,</span><span> score_left </span><span style=color:#5fb3b3>*</span><span> score_right</span><span style=color:#5fb3b3>))
</span><span>            </span><span style=color:#5fb3b3>})
</span><span>            </span><span style=color:#5fb3b3>.</span><span style=color:#69c>collect</span><span style=color:#5fb3b3>(),
</span><span>        </span><span style=color:#5f6364>// we want the union
</span><span>        Kind</span><span style=color:#5fb3b3>::</span><span>Or </span><span style=color:#5fb3b3>=> {
</span><span>            right</span><span style=color:#5fb3b3>.</span><span style=color:#69c>drain</span><span style=color:#5fb3b3>().</span><span style=color:#69c>for_each</span><span style=color:#5fb3b3>(|(</span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>right_score</span><span style=color:#5fb3b3>)| {
</span><span>                left</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>)
</span><span>                    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>and_modify</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>left_score</span><span style=color:#5fb3b3>| {
</span><span>                        </span><span style=color:#5f6364>// we use the addition to join scores
</span><span>                        </span><span style=color:#5fb3b3>*</span><span>left_score </span><span style=color:#5fb3b3>+=</span><span> right_score</span><span style=color:#5fb3b3>;
</span><span>                    </span><span style=color:#5fb3b3>})
</span><span>                    </span><span style=color:#5fb3b3>.</span><span style=color:#69c>or_insert</span><span style=color:#5fb3b3>(</span><span>right_score</span><span style=color:#5fb3b3>);
</span><span>            </span><span style=color:#5fb3b3>});
</span><span>            left
</span><span>        </span><span style=color:#5fb3b3>},
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>With this implementation, each index and each field is equally important. To make the result more relevant, we could introduce a system of weights (or boost) in the equation.<p>With our final query scores calculated, we can simply match the <code>EntryIndex</code> to the original identifier from the collection and return the content in the callback.<p><strong>Query Engine Achievements:</strong><ul><li>Lazy loading of indexes through caching<li>Efficient async execution using sequential processing<li>Memory-efficient query evaluation using RPN<li>Normalized scoring across different index types<li>Extensible aggregation system for combining results</ul><h2 id=conclusion>Conclusion</h2><p>In this fourth part of our search engine series, we've implemented a flexible and efficient search system that works across our different index types. We've tackled several key challenges:<p><strong>Key Achievements:</strong><ul><li>Built a flexible query language supporting complex boolean expressions<li>Implemented specialized filters for different data types<li>Created an efficient fuzzy search system using trigrams<li>Added prefix search capabilities using tries<li>Developed a robust scoring system based on BM25</ul><p>Our implementation carefully balances functionality with performance. By using cached file access and converting recursive operations to sequential ones, we've maintained good performance even with encryption overhead. The scoring system ensures results are relevant while remaining computationally efficient.<p>The search engine now supports various query types:<ul><li>Simple boolean matching (<code>public:true</code>)<li>Range queries for numbers (<code>created_at > 123456789</code>)<li>Exact matching for tags (<code>author:"alice"</code>)<li>Fuzzy text search with prefix matching (<code>title:starts_with("prog")</code>)<li>Complex expressions combining multiple conditions</ul></div><div class=page-footer><a href="https://github.com/jdrouet/jdrouet.github.io/blob/main/content/posts/202503311500-search-engine-part-4.md?plain=1" title="Help improve page /posts/202503311500-search-engine-part-4/" target=_blank>Suggest improvements</a></div></article></main></div><footer><a alt="Send me an email" class=text-xxl href=mailto:contact@jdrouet.fr target=_blank> <i class="icon icon-mail"></i> </a><a alt="My GitHub profile" class=text-xxl href=https://github.com/jdrouet target=_blank> <i class="icon icon-github"></i> </a><a alt="My LinkedIn profile" class=text-xxl href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <i class="icon icon-linkedin"></i> </a><a alt="Follow me on Mamot" class=text-xxl href=https://mamot.fr/@jdrouet target=_blank> <i class="icon icon-mastodon"></i> </a><a alt="Follow my RSS feed" class=text-xxl href=/atom.xml target=_blank> <i class="icon icon-rss"></i> </a><span class=copyright>¬© 2023 - 2025 J√©r√©mie Drouet</span></footer>