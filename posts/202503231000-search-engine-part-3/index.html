<!doctype html><html lang=en-US xml:lang=en-US><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="text/html;charset=utf-8" http-equiv=Content-Type><link href=/favicon.svg rel=icon type=image/svg><link title="Atom feed" href=/atom.xml rel=alternate type=application/atom+xml><link href=/main.css rel=stylesheet><meta content=#151515 name=theme-color><meta content=#151515 name=msapplication-navbutton-color><meta content=black-translucent name=apple-mobile-web-app-status-bar-style><meta content="index, follow" name=robots><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=googlebot><meta content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" name=bingbot><title>jdrouet > Building a search engine from scratch, in Rust: part 3</title><meta content=Zola name=generator><meta content="Or how we'll implement sharding and transactions for our search engine." name=description><meta content="J√©r√©mie Drouet" name=author><link href=/posts/202503231000-search-engine-part-3/ rel=canonical><meta content="Building a search engine from scratch, in Rust: part 3" property=og:title><meta content="Or how we'll implement sharding and transactions for our search engine." property=og:description><meta content=article property=og:type><meta content=/posts/202503231000-search-engine-part-3/ property=og:url><meta content=/images/logo.png property=og:image><meta content=jdrouet property=og:site_name><meta content=en_US property=og:locale><meta content=2025-04-05T00:00:00+00:00 property=article:published_time><body><header><div class=container><a href=/ id=a-title> <h1>üßë‚Äçüíª jdrouet</h1> </a><h2>My projects, my thoughts and other things.</h2><nav id=navbar><a alt="Link to Home" class=btn href=/> Home </a><a alt="Link to LinkedIn profile" class=btn href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <span class="icon icon-linkedin"></span>About me</a><a alt="Link to GitHub profile" class=btn href=https://github.com/jdrouet target=_blank> <span class="icon icon-github"></span>jdrouet</a><a alt="Link to Mastodon profile" class=btn href=https://mamot.fr/@jdrouet target=_blank> <span class="icon icon-mastodon"></span>@jdrouet</a></nav><div class=job-status><span class=job-status-dot>‚óè</span><span class=job-status-text> Open to new opportunities - <a href=https://www.linkedin.com/in/jeremiedrouet target=_blank>Let's connect on LinkedIn</a> or <a href=mailto:hire@jdrouet.fr>contact me</a> </span></div></div></header><div class=container><main><article class=page><div class=header-container><h2>ü¶Ä Building a search engine from scratch, in Rust: part 3</h2></div><div class=page-info><div class="page-tags mb-1em">Tags = [ <a class=page-tag href=/tags/rust/>rust</a>, <a class=page-tag href=/tags/search-engine/>search-engine</a>, <a class=page-tag href=/tags/webassembly/>webassembly</a>, <a class=page-tag href=/tags/encryption/>encryption</a>, <a class=page-tag href=/tags/cross-platform/>cross-platform</a>, <a class=page-tag href=/tags/tutorial/>tutorial</a>, <a class=page-tag href=/tags/performance/>performance</a> ]</div><time class="page-time smaller" datetime=2025-04-05T00:00:00+00:00> Posted on 2025-04-05 </time></div><div class=entry><p>In the <a href=../202503191700-search-engine-part-2/>previous article</a>, we implemented the core document structure and indexes for our search engine. Now, let's tackle how we'll make our search engine scalable through sharding and reliable through transactions.<h3 id=shard-definition>Shard Definition</h3><p>Here's how our sharding architecture organizes data across multiple shards:<pre class=language-ascii data-lang=ascii style=color:#cccece;background-color:#2b2c2f><code class=language-ascii data-lang=ascii><span>                 Manifest
</span><span>                +--------+
</span><span>                | shards |
</span><span>                +--------+
</span><span>                     |
</span><span>          +----------+-----------+
</span><span>          v          v           v
</span><span>    +---------+ +---------+ +---------+
</span><span>    | Shard 0 | | Shard 1 | | Shard 2 |
</span><span>    |---------| |---------| |---------|
</span><span>    | 0 - 100 | | 101-200 | | 201-300 |
</span><span>    +---------+ +---------+ +---------+
</span><span>        |           |           |
</span><span>    Collection  Collection  Collection
</span><span>     Indexes     Indexes     Indexes
</span></code></pre><p>At this point, we have everything we need to build a shard: a collection to list all the documents in the shard and an index for each type. A simple implementation of that shard would look like this.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>// an abstraction to be able to map the indexes
</span><span style=color:#c594c5>enum </span><span>AnyIndex </span><span style=color:#5fb3b3>{
</span><span>    Boolean</span><span style=color:#5fb3b3>(</span><span>BooleanIndex</span><span style=color:#5fb3b3>),
</span><span>    Integer</span><span style=color:#5fb3b3>(</span><span>IntegerIndex</span><span style=color:#5fb3b3>),
</span><span>    Tag</span><span style=color:#5fb3b3>(</span><span>TagIndex</span><span style=color:#5fb3b3>),
</span><span>    Text</span><span style=color:#5fb3b3>(</span><span>TextIndex</span><span style=color:#5fb3b3>),
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>struct </span><span>Shard </span><span style=color:#5fb3b3>{
</span><span>    collection</span><span style=color:#5fb3b3>:</span><span> Collection,
</span><span>    indexes</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>Kind, AnyIndex</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>But this is a single shard representation, we might have several and need to have a representation for all of them.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>struct </span><span>Manager </span><span style=color:#5fb3b3>{
</span><span>    shards</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u64</span><span>, Shard</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>With this representation, the <code>u64</code> in the <code>BTreeMap</code> will represent the minimum in the range of partition handled by that shard. When initialized, the first shard key will be <code>0</code>.<p>But the two previous representations are actually wrong: this would mean that we'll load in memory the entire search engine, which doesn't scale. Instead, the <code>Shard</code> structure will only contain the filenames of the collection and indexes, which will be loaded in memory only when needed, and written to disk when they are not needed anymore.<p>The <code>Manager</code> structure can then be renamed to <code>Manifest</code> and will be, as well, persisting on disk, representing the state of the search engine at a given point in time.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>struct </span><span>Manifest </span><span style=color:#5fb3b3>{
</span><span>    shards</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u64</span><span>, Shard</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#c594c5>struct </span><span>Shard </span><span style=color:#5fb3b3>{
</span><span>    collection</span><span style=color:#5fb3b3>:</span><span> Filename,
</span><span>    indexes</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>Kind, Filename</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This manifest will be stored in the working directory as <code>manifest.bin</code> and every file (collections and indexes) will have a random name.<p>Sharding architecture highlights:<ul><li>Manifest-based shard management<li>File-based storage with lazy loading<li>Transaction support for concurrent operations<li>Dynamic shard splitting based on size<li>Recovery mechanism for incomplete transactions</ul><h4 id=transaction-mechanism>Transaction Mechanism</h4><p>This level of abstraction for the manifest allows us to add or delete shards when needed but there's an issue: we cannot block the access to the search engine each time we insert a document. We should be able to insert a set of documents while using the index and just block its access when writing the updated manifest to disk.<p>Following a similar mechanism to a transactional database, inserting data will require initializing a transaction, which will create a temporary manifest file which will contain the names of all the original indexes and the names of the indexes that have been updated. Updating a collection or an index will create a new file on disk but non updated indexes will remain the same.<pre class=language-ascii data-lang=ascii style=color:#cccece;background-color:#2b2c2f><code class=language-ascii data-lang=ascii><span>    Original State         Transaction             Committed State
</span><span>    +--------------+       +--------------+        +--------------+
</span><span>    | manifest.bin |       | manifest.tx  |        | manifest.bin |
</span><span>    +--------------+       +--------------+        +--------------+
</span><span>    | idx1.bin     |       | idx1.bin     |        | idx1.bin     |
</span><span>    | idx2.bin     |  -->  | idx2_new.bin |  -->   | idx2_new.bin |
</span><span>    | idx3.bin     |       | idx3.bin     |        | idx3.bin     |
</span><span>    +--------------+       +--------------+        +--------------+
</span></code></pre><p>This would give us this code for shard management<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// represents a file during a transaction
</span><span style=color:#c594c5>struct </span><span>TxFile </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// original file path, if it exists
</span><span>    </span><span style=color:#5f6364>// a shard can not have any boolean index but it can be created after an update
</span><span>    base</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>Filename</span><span style=color:#5fb3b3>></span><span>,
</span><span>    </span><span style=color:#5f6364>/// new file path after changes, if modified
</span><span>    </span><span style=color:#5f6364>// the filename once the transaction is committed
</span><span>    next</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>Filename</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>/// represents a shard during a transaction
</span><span style=color:#c594c5>struct </span><span>TxShard </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// collection file state
</span><span>    collection</span><span style=color:#5fb3b3>:</span><span> TxFile,
</span><span>    </span><span style=color:#5f6364>/// index files state for each kind
</span><span>    indexes</span><span style=color:#5fb3b3>: </span><span>HashMap</span><span style=color:#5fb3b3><</span><span>Kind, TxFile</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>/// manages the state of all shards during a transaction
</span><span style=color:#c594c5>struct </span><span>TxManifest </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// maps shard keys to their transaction state
</span><span>    </span><span style=color:#5f6364>/// uses BTreeMap to maintain order for efficient splits
</span><span>    shards</span><span style=color:#5fb3b3>: </span><span>BTreeMap</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>u64</span><span>, TxShard</span><span style=color:#5fb3b3>></span><span>,
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This transaction manifest would be written to the filesystem depending on the platform: in the browser, since we cannot know when the page will be closed, it's better to write it after each operation, while on mobile, the app can do a simple operation before closing. This provides a nice way of being able to recover a transaction that has not been committed.<p>That commit operation simply consists in, for each file of each shard, taking the <code>next</code> filename if exists or the <code>base</code> one, and write it in the <code>manifest.bin</code>. This commit operation is atomic, and then less prone to errors.<h4 id=sharding-or-not-sharding>Sharding, Or Not Sharding</h4><p>Before talking about how to shard, we should talk about when we should decide to shard.<p>Considering I've decided to leave the limit configurable depending on the size of the files, we have to be able to determine the size of a index file, once serialized and encrypted. Considering the time needed to serialize and encrypt is CPU bound (and after some experiments), writing the encrypted file to disk in order to determine its size brings too much overhead and kills the performance.<p>The second option I came up with was to compute the size of the index each time it gets updated. It's quite time consuming and uses a brute-force approach, but it's still minimal compared to the time needed to serialize and encrypt it. And we'll be able to improve this performance later, there's an entire section dedicated for that.<p>Considering the redundancy in the structure of the indexes, we can make something smart that won't require too much repeat. Let's implement a <code>ContentSize</code> that evaluates the size of the structure.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>/// provides size estimation for optimizing shard splits
</span><span style=color:#c594c5>trait </span><span>ContentSize </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// returns estimated size in bytes when serialized
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>estimate_size</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>usize</span><span style=color:#5fb3b3>;
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>// for constant value sizes
</span><span style=color:#69c>macro_rules! </span><span>const_size </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5fb3b3>(</span><span style=color:#f99157>$name</span><span style=color:#5fb3b3>:</span><span style=color:#c594c5>ident</span><span style=color:#5fb3b3>) => {
</span><span>        </span><span style=color:#c594c5>impl </span><span>ContentSize </span><span style=color:#c594c5>for </span><span>$name </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>fn </span><span style=color:#69c>estimate_size</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>usize </span><span style=color:#5fb3b3>{
</span><span>                std</span><span style=color:#5fb3b3>::</span><span>mem</span><span style=color:#5fb3b3>::</span><span>size_of</span><span style=color:#5fb3b3>::<</span><span>$name</span><span style=color:#5fb3b3>>()
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>// and for other types like u16, u32, u64 and bool
</span><span>const_size!</span><span style=color:#5fb3b3>(</span><span style=color:#c594c5>u8</span><span style=color:#5fb3b3>);
</span><span>
</span><span style=color:#5f6364>// let's consider a string just for its content size
</span><span style=color:#c594c5>impl</span><span style=color:#5fb3b3><</span><span>T</span><span style=color:#5fb3b3>: </span><span style=color:#fac863>AsRef</span><span style=color:#5fb3b3><</span><span style=color:#c594c5>str</span><span style=color:#5fb3b3>>></span><span> ContentSize </span><span style=color:#c594c5>for </span><span>T </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// estimates string size based on character count
</span><span>    </span><span style=color:#5f6364>/// note: This is an approximation and doesn't account for encoding overhead
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>estimate_size</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>usize </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>as_ref</span><span style=color:#5fb3b3>().</span><span style=color:#69c>len</span><span style=color:#5fb3b3>()
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span><span>
</span><span style=color:#5f6364>// for maps, similar
</span><span style=color:#c594c5>impl</span><span style=color:#5fb3b3><</span><span>K</span><span style=color:#5fb3b3>:</span><span> ContentSize, V</span><span style=color:#5fb3b3>:</span><span> ContentSize</span><span style=color:#5fb3b3>> </span><span>for HashMap</span><span style=color:#5fb3b3><</span><span>K, V</span><span style=color:#5fb3b3>> {
</span><span>    </span><span style=color:#5f6364>/// recursively estimates size of all keys and values
</span><span>    </span><span style=color:#5f6364>/// used to determine when to split shards
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>estimate_size</span><span style=color:#5fb3b3>(&</span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#c594c5>usize </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter</span><span style=color:#5fb3b3>().</span><span style=color:#69c>fold</span><span style=color:#5fb3b3>(</span><span style=color:#f99157>0</span><span style=color:#5fb3b3>, |</span><span style=color:#f99157>acc</span><span style=color:#5fb3b3>, (</span><span style=color:#f99157>key</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>value</span><span style=color:#5fb3b3>)| </span><span>acc </span><span style=color:#5fb3b3>+</span><span> key</span><span style=color:#5fb3b3>.</span><span style=color:#69c>estimate_size</span><span style=color:#5fb3b3>() +</span><span> value</span><span style=color:#5fb3b3>.</span><span style=color:#69c>estimate_size</span><span style=color:#5fb3b3>())
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>With this in hand, we can implement it for all the indexes and we'll have a rough idea of the size of the file. Considering that encryption will add a bit of overhead in size, we can decide to split the index when it reaches 90% of the limit size.<p>But now the question is: how to implement the sharding mechanism? It's quite simple and will be based on what we put in place earlier in this article.<p>Here's a visual example of how a shard splits:<pre class=language-ascii data-lang=ascii style=color:#cccece;background-color:#2b2c2f><code class=language-ascii data-lang=ascii><span>Before Split:
</span><span>    Shard 0 [0-200]
</span><span>    +---------------+
</span><span>    | Doc1  [50]    |
</span><span>    | Doc2  [75]    |
</span><span>    | Doc3  [125]   |
</span><span>    | Doc4  [175]   |
</span><span>    +---------------+
</span><span>
</span><span>After Split:
</span><span>    Shard 0 [0-100]     Shard 1 [101-200]
</span><span>    +---------------+   +----------------+
</span><span>    | Doc1  [50]    |   | Doc3  [125]    |
</span><span>    | Doc2  [75]    |   | Doc4  [175]    |
</span><span>    +---------------+   +----------------+
</span></code></pre><p>In the <code>Collection</code> structure lives a <code>BTreeMap</code> of all the entries by sharding value. A simple way to shard is just to split that <code>BTreeMap</code> at its center of gravity so that we have almost the same number of documents in both shard.<p>Now we just have to implement a splitting function on the collection and all the indexes.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#c594c5>impl </span><span>Collection </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>/// attempts to split the collection into two roughly equal parts
</span><span>    </span><span style=color:#5f6364>/// returns None if splitting is not possible (e.g., all documents have same shard value)
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>split</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span style=color:#5fb3b3>) -> </span><span style=color:#fac863>Option</span><span style=color:#5fb3b3><</span><span>Collection</span><span style=color:#5fb3b3>> {
</span><span>        </span><span style=color:#5f6364>// if all the entries have the same sharding value, it's not possible to split considering
</span><span>        </span><span style=color:#5f6364>// a sharding value can only be in one shard.
</span><span>        </span><span style=color:#c594c5>if </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>sharding </span><span style=color:#5fb3b3>< </span><span style=color:#f99157>2 </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#c594c5>return </span><span style=color:#fac863>None</span><span style=color:#5fb3b3>;
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>
</span><span>        </span><span style=color:#5f6364>// calculate target size for new collection
</span><span>        </span><span style=color:#c594c5>let</span><span> total_count </span><span style=color:#5fb3b3>= </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>entries_by_name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>len</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#c594c5>let</span><span> half_count </span><span style=color:#5fb3b3>=</span><span> total_count </span><span style=color:#5fb3b3>/ </span><span style=color:#f99157>2</span><span style=color:#5fb3b3>;
</span><span>
</span><span>        </span><span style=color:#c594c5>let mut</span><span> new_collection </span><span style=color:#5fb3b3>= </span><span>Collection</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>();
</span><span>
</span><span>        </span><span style=color:#5f6364>// keep moving entries until we reach approximately half size
</span><span>        </span><span style=color:#c594c5>while</span><span> new_collection</span><span style=color:#5fb3b3>.</span><span>entries_by_name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>len</span><span style=color:#5fb3b3>() <</span><span> half_count </span><span style=color:#5fb3b3>&& </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>sharding</span><span style=color:#5fb3b3>.</span><span style=color:#69c>len</span><span style=color:#5fb3b3>() > </span><span style=color:#f99157>1 </span><span style=color:#5fb3b3>{
</span><span>            </span><span style=color:#5f6364>// if this happens, it means we moved everything from the old shard, which shouldn't be possible
</span><span>            </span><span style=color:#5f6364>// which shouldn't happen considering that we check the number of shards
</span><span>            </span><span style=color:#c594c5>let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>((</span><span>shard_value</span><span style=color:#5fb3b3>,</span><span> entries</span><span style=color:#5fb3b3>)) = </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>sharding</span><span style=color:#5fb3b3>.</span><span style=color:#69c>pop_last</span><span style=color:#5fb3b3>() {
</span><span>                </span><span style=color:#c594c5>return</span><span> new_collection</span><span style=color:#5fb3b3>;
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>            </span><span style=color:#5f6364>// moving from the old collection to the new collection one by one
</span><span>            </span><span style=color:#c594c5>for</span><span> entry_index </span><span style=color:#5fb3b3>in</span><span> entries </span><span style=color:#5fb3b3>{
</span><span>                </span><span style=color:#c594c5>if let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>name</span><span style=color:#5fb3b3>) = </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>entries_by_index</span><span style=color:#5fb3b3>.</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&</span><span>entry_index</span><span style=color:#5fb3b3>) {
</span><span>                    </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>entries_by_name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(&</span><span>name</span><span style=color:#5fb3b3>);
</span><span>                    new_collection</span><span style=color:#5fb3b3>.</span><span>entries_by_index</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>,</span><span> name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>());
</span><span>                    new_collection</span><span style=color:#5fb3b3>.</span><span>entries_by_name</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>name</span><span style=color:#5fb3b3>,</span><span> entry_index</span><span style=color:#5fb3b3>);
</span><span>                </span><span style=color:#5fb3b3>}
</span><span>            </span><span style=color:#5fb3b3>}
</span><span>            new_collection</span><span style=color:#5fb3b3>.</span><span>sharding</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>shard_value</span><span style=color:#5fb3b3>,</span><span> entries</span><span style=color:#5fb3b3>);
</span><span>        </span><span style=color:#5fb3b3>}
</span><span>
</span><span>        new_collection
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>This will give us a new collection if it was possible to split it. If it's possible, we can now split all the indexes.<pre class=language-rust data-lang=rust style=color:#cccece;background-color:#2b2c2f><code class=language-rust data-lang=rust><span style=color:#5f6364>// similar for each index
</span><span style=color:#c594c5>impl </span><span>BooleanIndex </span><span style=color:#5fb3b3>{
</span><span>    </span><span style=color:#5f6364>// we just create a new index an move every item from the old entries to the new index
</span><span>    </span><span style=color:#c594c5>fn </span><span style=color:#69c>split</span><span style=color:#5fb3b3>(&</span><span style=color:#c594c5>mut </span><span style=color:#f99157>self</span><span>, </span><span style=color:#f99157>entries</span><span style=color:#5fb3b3>: &</span><span>HashSet</span><span style=color:#5fb3b3><</span><span>EntryIndex</span><span style=color:#5fb3b3>>) -></span><span> BooleanIndex </span><span style=color:#5fb3b3>{
</span><span>        </span><span style=color:#c594c5>let mut</span><span> next </span><span style=color:#5fb3b3>= </span><span>BooleanIndex</span><span style=color:#5fb3b3>::</span><span>default</span><span style=color:#5fb3b3>();
</span><span>        </span><span style=color:#ec5f67>self</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter_with_mut</span><span style=color:#5fb3b3>(|(</span><span style=color:#f99157>term</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>term_postings</span><span style=color:#5fb3b3>)| {
</span><span>            term_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter_with_mut</span><span style=color:#5fb3b3>(|(</span><span style=color:#f99157>attribute</span><span style=color:#5fb3b3>, </span><span style=color:#f99157>attribute_postings</span><span style=color:#5fb3b3>)| {
</span><span>                </span><span style=color:#5f6364>// fetch the intersection
</span><span>                </span><span style=color:#c594c5>let</span><span> intersection </span><span style=color:#5fb3b3>=</span><span> entries</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter</span><span style=color:#5fb3b3>().</span><span style=color:#69c>filter</span><span style=color:#5fb3b3>(|</span><span style=color:#f99157>entry_index</span><span style=color:#5fb3b3>| </span><span>attribute_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>contains_key</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>)).</span><span style=color:#69c>collect</span><span style=color:#5fb3b3>();
</span><span>                </span><span style=color:#c594c5>if </span><span style=color:#5fb3b3>!</span><span>intersection</span><span style=color:#5fb3b3>.</span><span style=color:#69c>is_empty</span><span style=color:#5fb3b3>() {
</span><span>                    </span><span style=color:#5f6364>// only create the postings if there is an intersection
</span><span>                    </span><span style=color:#c594c5>let</span><span> next_term_postings </span><span style=color:#5fb3b3>=</span><span> next</span><span style=color:#5fb3b3>.</span><span>content</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>term</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>()).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>                    </span><span style=color:#c594c5>let</span><span> next_attribute_postings </span><span style=color:#5fb3b3>=</span><span> next_term_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>entry</span><span style=color:#5fb3b3>(</span><span>attribute</span><span style=color:#5fb3b3>.</span><span style=color:#69c>clone</span><span style=color:#5fb3b3>()).</span><span style=color:#69c>or_default</span><span style=color:#5fb3b3>();
</span><span>                    </span><span style=color:#c594c5>for</span><span> entry_index </span><span style=color:#5fb3b3>in</span><span> intersection</span><span style=color:#5fb3b3>.</span><span style=color:#69c>iter</span><span style=color:#5fb3b3>() {
</span><span>                        </span><span style=color:#5f6364>// remove from the old one and insert in the new one
</span><span>                        </span><span style=color:#c594c5>if let </span><span style=color:#fac863>Some</span><span style=color:#5fb3b3>(</span><span>entry_posting</span><span style=color:#5fb3b3>) =</span><span> attribute_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>remove</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>) {
</span><span>                            next_attribute_postings</span><span style=color:#5fb3b3>.</span><span style=color:#69c>insert</span><span style=color:#5fb3b3>(</span><span>entry_index</span><span style=color:#5fb3b3>,</span><span> entry_posting</span><span style=color:#5fb3b3>);
</span><span>                        </span><span style=color:#5fb3b3>}
</span><span>                    </span><span style=color:#5fb3b3>}
</span><span>                </span><span style=color:#5fb3b3>}
</span><span>                </span><span style=color:#5fb3b3>!</span><span>intersection</span><span style=color:#5fb3b3>.</span><span style=color:#69c>is_empty</span><span style=color:#5fb3b3>()
</span><span>            </span><span style=color:#5fb3b3>})
</span><span>        </span><span style=color:#5fb3b3>});
</span><span>        next
</span><span>    </span><span style=color:#5fb3b3>}
</span><span style=color:#5fb3b3>}
</span></code></pre><p>After this creation of a new shard, we can inject it in the transaction manifest, with the sharding key being the minimum of all the sharding keys, which can simply be accessed using the <a href=https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.first_key_value rel=noopener target=_blank><code>first_key_value</code> function of the <code>BTreeMap</code></a>. And at the next commit, it will be possible to search in it.<h2 id=conclusion>Conclusion</h2><p>In this third part of our series on building a search engine, we've implemented the architecture for sharding and transactions. We've tackled several fundamental challenges:<ul><li>Designing a flexible yet efficient document schema<li>Implementing specialized indexes for different data types<li>Creating a robust sharding mechanism<li>Building a transaction-safe storage system</ul><p>Our implementation prioritizes both performance and safety, with careful consideration for resource constraints across different platforms. The use of numeric indexes instead of strings, lazy loading of shards, and atomic transactions all contribute to making our search engine efficient and reliable.<p><strong>Key Achievements:</strong><ul><li>Type-safe document schema with support for multiple values<li>Memory-efficient index structures<li>Platform-independent storage abstraction<li>Transaction-safe operations<li>Dynamic sharding capability</ul><h3 id=what-s-next>What's Next?</h3><p>In the part 4: Search Implementation, we'll build upon these foundations to implement the actual search functionality.<p>Stay tuned to learn how we'll turn these carefully designed data structures into a fully functional search engine that can handle complex queries across all our supported data types!</div><div class=page-footer><a href="https://github.com/jdrouet/jdrouet.github.io/blob/main/content/posts/202503231000-search-engine-part-3.md?plain=1" title="Help improve page /posts/202503231000-search-engine-part-3/" target=_blank>Suggest improvements</a></div></article></main></div><footer><a alt="Send me an email" class=text-xxl href=mailto:contact@jdrouet.fr target=_blank> <i class="icon icon-mail"></i> </a><a alt="My GitHub profile" class=text-xxl href=https://github.com/jdrouet target=_blank> <i class="icon icon-github"></i> </a><a alt="My LinkedIn profile" class=text-xxl href=https://www.linkedin.com/in/jeremiedrouet target=_blank> <i class="icon icon-linkedin"></i> </a><a alt="Follow me on Mamot" class=text-xxl href=https://mamot.fr/@jdrouet target=_blank> <i class="icon icon-mastodon"></i> </a><a alt="Follow my RSS feed" class=text-xxl href=/atom.xml target=_blank> <i class="icon icon-rss"></i> </a><span class=copyright>¬© 2023 - 2025 J√©r√©mie Drouet</span></footer>